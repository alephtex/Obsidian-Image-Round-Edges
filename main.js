/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageRoundedFramePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultUnit: "percent",
  defaultPercent: 25,
  defaultPx: 24,
  rememberLast: true,
  lastUnit: "percent",
  lastPercent: 25,
  lastPx: 24
};
var RoundedFrameSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Image Rounded Frame" });
    new import_obsidian.Setting(containerEl).setName("Default unit").setDesc("Initial unit whenever you add a rounded frame.").addDropdown((dropdown) => {
      dropdown.addOption("percent", "Percent").addOption("px", "Pixels");
      dropdown.setValue(this.plugin.settings.defaultUnit);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultUnit = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default percent radius").setDesc("Used when unit is percent.").addSlider((slider) => {
      slider.setLimits(0, 100, 1).setDynamicTooltip().setValue(this.plugin.settings.defaultPercent);
      slider.onChange(async (value) => {
        this.plugin.settings.defaultPercent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default pixel radius").setDesc("Used when unit is pixels.").addText((text) => {
      text.setPlaceholder("24").setValue(String(this.plugin.settings.defaultPx)).onChange(async (value) => {
        const numeric = Number(value);
        this.plugin.settings.defaultPx = Number.isFinite(numeric) ? Math.max(0, Math.min(400, numeric)) : 0;
        text.setValue(String(this.plugin.settings.defaultPx));
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Remember last used values").setDesc("Reuse the most recent radius and unit until Obsidian restarts.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.rememberLast);
      toggle.onChange(async (value) => {
        this.plugin.settings.rememberLast = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// style-manager.ts
var CLASS_NAME = "rounded-frame-img";
var RoundedStyleManager = class {
  constructor() {
    this.seen = /* @__PURE__ */ new Set();
    this.styleEl = document.head.querySelector("#rounded-frame-style");
    if (!this.styleEl) {
      this.styleEl = document.createElement("style");
      this.styleEl.id = "rounded-frame-style";
      document.head.appendChild(this.styleEl);
      this.appendRule(`img.${CLASS_NAME}{display:inline-block;border:2px solid var(--background-modifier-border);}`);
    }
  }
  ensureRule(unit, value) {
    return CLASS_NAME;
  }
  appendRule(rule) {
    this.styleEl.appendChild(document.createTextNode(`${rule}
`));
  }
};

// modal.ts
var import_obsidian2 = require("obsidian");
var RoundedFrameModal = class extends import_obsidian2.Modal {
  constructor(app, opts) {
    super(app);
    this.opts = opts;
    this.radius = opts.initialRadius;
    this.unit = opts.initialUnit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rounded-frame-modal");
    contentEl.createEl("h2", { text: "Rounded frame" });
    const unitRow = contentEl.createDiv("rounded-frame-unit-row");
    const percentBtn = unitRow.createEl("button", { text: "Percent" });
    const pixelBtn = unitRow.createEl("button", { text: "Pixels" });
    let percentRadius = this.unit === "percent" ? this.radius : this.opts.defaultPercent;
    let pixelRadius = this.unit === "px" ? this.radius : this.opts.defaultPx;
    const percentSection = contentEl.createDiv("rounded-frame-section");
    const percentValue = percentSection.createSpan({ text: `${percentRadius}%` });
    const percentSlider = percentSection.createEl("input", { type: "range" });
    percentSlider.addClass("rounded-frame-slider");
    percentSlider.min = "0";
    percentSlider.max = "100";
    percentSlider.step = "1";
    percentSlider.value = String(percentRadius);
    const pixelSection = contentEl.createDiv("rounded-frame-section");
    const pixelInput = pixelSection.createEl("input", { type: "number" });
    pixelInput.addClass("rounded-frame-number");
    pixelInput.min = "0";
    pixelInput.max = "400";
    pixelInput.step = "1";
    pixelInput.value = String(pixelRadius);
    const previewContainer = contentEl.createDiv("rounded-frame-preview");
    let previewImg = null;
    if (this.opts.imageSrc) {
      previewImg = previewContainer.createEl("img", {
        attr: { src: this.opts.imageSrc, alt: "Preview image" }
      });
      previewImg.addClass("rounded-frame-preview-img");
    }
    const buttonRow = contentEl.createDiv("rounded-frame-button-row");
    const resetBtn = buttonRow.createEl("button", { text: "Reset" });
    const cancelBtn = buttonRow.createEl("button", { text: "Cancel" });
    const applyBtn = buttonRow.createEl("button", { text: "Apply" });
    applyBtn.addClass("mod-cta");
    const syncUI = () => {
      if (this.unit === "percent") {
        percentSection.removeClass("rounded-frame-hidden");
        pixelSection.addClass("rounded-frame-hidden");
        percentSlider.value = String(percentRadius);
        percentValue.setText(`${percentRadius}%`);
      } else {
        pixelSection.removeClass("rounded-frame-hidden");
        percentSection.addClass("rounded-frame-hidden");
        pixelInput.value = String(pixelRadius);
      }
      if (previewImg) {
        const calcRadius = () => {
          const w = previewImg.naturalWidth || previewImg.width || previewImg.offsetWidth;
          const h = previewImg.naturalHeight || previewImg.height || previewImg.offsetHeight;
          if (!w || !h)
            return;
          const baseDimension = Math.min(w, h);
          const maxRadius = baseDimension / 2;
          let radiusPx;
          if (this.unit === "percent") {
            radiusPx = percentRadius / 100 * baseDimension;
          } else {
            radiusPx = pixelRadius;
          }
          radiusPx = Math.min(radiusPx, maxRadius);
          previewImg.style.borderRadius = Math.max(0, radiusPx) + "px";
        };
        if (previewImg.complete) {
          calcRadius();
        } else {
          previewImg.addEventListener("load", calcRadius, { once: true });
        }
      }
    };
    const setUnit = (unit) => {
      this.unit = unit;
      this.radius = unit === "percent" ? percentRadius : pixelRadius;
      percentBtn.toggleClass("mod-cta", unit === "percent");
      pixelBtn.toggleClass("mod-cta", unit === "px");
      syncUI();
    };
    percentBtn.addEventListener("click", () => setUnit("percent"));
    pixelBtn.addEventListener("click", () => setUnit("px"));
    percentSlider.addEventListener("input", (evt) => {
      percentRadius = Number(evt.target.value);
      this.radius = percentRadius;
      syncUI();
    });
    pixelInput.addEventListener("input", (evt) => {
      const value = Number(evt.target.value);
      pixelRadius = this.clamp(Number.isFinite(value) ? value : 0, 0, 400);
      this.radius = pixelRadius;
      syncUI();
    });
    resetBtn.addEventListener("click", () => {
      if (this.unit === "percent") {
        percentRadius = this.opts.defaultPercent;
        this.radius = percentRadius;
      } else {
        pixelRadius = this.opts.defaultPx;
        this.radius = pixelRadius;
      }
      syncUI();
    });
    cancelBtn.addEventListener("click", () => this.close());
    applyBtn.addEventListener("click", () => {
      this.opts.onSubmit(this.radius, this.unit);
      this.close();
    });
    setUnit(this.unit);
  }
  onClose() {
    this.contentEl.empty();
  }
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
};

// main.ts
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var ImageRoundedFramePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.style = new RoundedStyleManager();
  }
  async onload() {
    await this.loadSettings();
    this.ensureUiStyles();
    this.addSettingTab(new RoundedFrameSettingTab(this.app, this));
    await this.ensurePythonScript();
    this.addCommand({
      id: "rounded-frame-apply-visible",
      name: "Rounded frame: apply to visible images",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view)
          return false;
        const visible = this.getVisibleImages(view);
        if (checking)
          return visible.length > 0;
        if (visible.length === 0)
          return false;
        const matches = [];
        for (const img of visible) {
          const src = img.getAttribute("src") || img.getAttribute("data-src") || "";
          const m = this.locateMatchBySrc(view, src);
          if (m)
            matches.push(m);
        }
        const unique = this.uniqueMatches(matches);
        if (unique.length === 0)
          return false;
        const first = visible[0];
        const firstSrc = first.getAttribute("src") || first.getAttribute("data-src") || void 0;
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSrc: firstSrc,
          onSubmit: (radius, unit) => this.applyRoundedFrameToMatches(view, unique, radius, unit)
        });
        modal.open();
        return true;
      }
    });
    this.addCommand({
      id: "rounded-frame-apply-all",
      name: "Rounded frame: apply to all images in note",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view)
          return false;
        const all = this.getAllMatches(view);
        if (checking)
          return all.length > 0;
        if (all.length === 0)
          return false;
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSrc: void 0,
          onSubmit: (radius, unit) => this.applyRoundedFrameToMatches(view, all, radius, unit)
        });
        modal.open();
        return true;
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  ensureUiStyles() {
    if (document.head.querySelector("#rounded-frame-ui"))
      return;
    const style = document.createElement("style");
    style.id = "rounded-frame-ui";
    style.textContent = ".rounded-frame-modal{padding:20px;min-width:360px;}.rounded-frame-unit-row{display:flex;gap:8px;margin-bottom:12px;}.rounded-frame-unit-row button{flex:1;}.rounded-frame-section{margin-bottom:12px;}.rounded-frame-hidden{display:none;}.rounded-frame-slider{width:100%;}.rounded-frame-number{width:100%;}.rounded-frame-preview{text-align:center;margin:16px 0;}.rounded-frame-preview-img{max-width:220px;max-height:220px;border:2px solid var(--background-modifier-border);object-fit:contain;}.rounded-frame-button-row{display:flex;justify-content:flex-end;gap:10px;margin-top:16px;}";
    document.head.appendChild(style);
  }
  async ensurePythonScript() {
    const pythonScript = path.join(this.app.vault.configDir, "plugins", "image-rounded-frame", "round_image.py");
    const pluginDir = path.dirname(pythonScript);
    if (!fs.existsSync(pluginDir)) {
      fs.mkdirSync(pluginDir, { recursive: true });
    }
    const sourceScript = path.join(__dirname, "round_image.py");
    if (fs.existsSync(sourceScript) && !fs.existsSync(pythonScript)) {
      fs.copyFileSync(sourceScript, pythonScript);
      fs.chmodSync(pythonScript, 493);
    }
  }
  // Right-click integrations removed; command-driven flow only
  refreshMatch(editor, match) {
    var _a;
    const line = editor.getLine(match.lineNumber);
    return line.slice(match.start, match.end) === match.raw ? match : (_a = this.findMatchInLine(line, match.lineNumber, { targetSrc: match.path })) != null ? _a : null;
  }
  findMatchInLine(line, lineNumber, opts = {}) {
    var _a;
    const candidates = this.collectMatches(line, lineNumber);
    if (opts.targetSrc) {
      const matched = candidates.find((c) => this.pathsMatch(opts.targetSrc, c.path));
      if (matched)
        return matched;
    }
    if (opts.cursorCh !== void 0) {
      const matched = candidates.find((c) => opts.cursorCh >= c.start && opts.cursorCh <= c.end);
      if (matched)
        return matched;
    }
    return (_a = candidates[0]) != null ? _a : null;
  }
  locateMatchBySrc(view, src) {
    if (!src)
      return null;
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const match = this.findMatchInLine(lines[lineNumber], lineNumber, { targetSrc: src });
      if (match)
        return match;
    }
    return null;
  }
  getAllMatches(view) {
    const out = [];
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const list = this.collectMatches(lines[lineNumber], lineNumber);
      for (const m of list)
        out.push(m);
    }
    return this.uniqueMatches(out);
  }
  getVisibleImages(view) {
    const root = view.containerEl;
    const imgs = Array.from(root.querySelectorAll("img"));
    const viewportH = window.innerHeight || document.documentElement.clientHeight;
    return imgs.filter((img) => {
      const r = img.getBoundingClientRect();
      const visible = r.bottom > 0 && r.top < viewportH && r.width > 0 && r.height > 0;
      const src = img.getAttribute("src") || img.getAttribute("data-src");
      return visible && !!src;
    });
  }
  uniqueMatches(matches) {
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const m of matches) {
      const key = `${m.lineNumber}:${m.start}:${m.end}`;
      if (!seen.has(key)) {
        seen.add(key);
        out.push(m);
      }
    }
    return out;
  }
  async applyRoundedFrameToMatches(view, matches, radius, unit) {
    const editor = view.editor;
    const refreshed = [];
    for (const m of matches) {
      const updated = this.refreshMatch(editor, m);
      if (updated)
        refreshed.push(updated);
    }
    refreshed.sort((a, b) => a.lineNumber === b.lineNumber ? b.start - a.start : b.lineNumber - a.lineNumber);
    for (const m of refreshed) {
      try {
        const file = this.resolveTFile(view, m.path);
        if (!file) {
          new import_obsidian3.Notice(`Could not find file: ${m.path}`, 2e3);
          continue;
        }
        const { blob, newPath } = await this.roundImageFile(file, radius, unit);
        await this.writeRoundedVersion(newPath, blob);
        this.updateReference(editor, view, m, newPath);
        new import_obsidian3.Notice(`Rounded image saved: ${newPath}`, 1500);
      } catch (err) {
        new import_obsidian3.Notice(`Failed to round image: ${m.path} - ${err}`, 3e3);
      }
    }
    this.storeLast(radius, unit);
  }
  collectMatches(line, lineNumber) {
    var _a;
    const matches = [];
    const mdRegex = /!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)/g;
    let md;
    while ((md = mdRegex.exec(line)) !== null) {
      matches.push({
        lineNumber,
        start: md.index,
        end: md.index + md[0].length,
        path: md[2].trim(),
        alt: (md[1] || "").trim(),
        raw: md[0],
        kind: "markdown"
      });
    }
    const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
    let wiki;
    while ((wiki = wikiRegex.exec(line)) !== null) {
      const path2 = wiki[1].trim();
      const alt = (wiki[2] || wiki[1] || "").trim();
      matches.push({
        lineNumber,
        start: wiki.index,
        end: wiki.index + wiki[0].length,
        path: path2,
        alt,
        raw: wiki[0],
        kind: "wikilink"
      });
    }
    const htmlRegex = /<img\s+[^>]*>/gi;
    let tag;
    while ((tag = htmlRegex.exec(line)) !== null) {
      const raw = tag[0];
      const path2 = this.getAttr(raw, "src");
      if (!path2)
        continue;
      matches.push({
        lineNumber,
        start: tag.index,
        end: tag.index + raw.length,
        path: path2,
        alt: (_a = this.getAttr(raw, "alt")) != null ? _a : "",
        raw,
        kind: "html"
      });
    }
    return matches;
  }
  getAttr(tag, name) {
    var _a, _b;
    const attr = new RegExp(`${name}\\s*=\\s*("([^"]*)"|'([^']*)')`, "i").exec(tag);
    if (!attr)
      return null;
    return ((_b = (_a = attr[2]) != null ? _a : attr[3]) != null ? _b : "").trim();
  }
  resolveTFile(view, link) {
    var _a, _b, _c, _d;
    if (/^https?:/i.test(link))
      return null;
    let decodedLink = decodeURIComponent(link);
    decodedLink = decodedLink.replace(/^\.\//, "");
    const base = (_b = (_a = view.file) == null ? void 0 : _a.path) != null ? _b : "";
    let file = this.app.metadataCache.getFirstLinkpathDest(decodedLink, base);
    if (file)
      return file;
    file = this.app.metadataCache.getFirstLinkpathDest(decodedLink, base);
    if (file)
      return file;
    file = this.app.vault.getAbstractFileByPath(decodedLink);
    if (file)
      return file;
    if (view.file) {
      const parentPath = (_d = (_c = view.file.parent) == null ? void 0 : _c.path) != null ? _d : "";
      const fullPath = parentPath ? `${parentPath}/${decodedLink}` : decodedLink;
      file = this.app.vault.getAbstractFileByPath(fullPath);
      if (file)
        return file;
    }
    return null;
  }
  async roundImageFile(file, radius, unit) {
    var _a, _b;
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const newPath = folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png`;
    try {
      await this.roundImageWithPython(file.path, newPath, radius, unit);
      const arrayBuffer = await this.app.vault.readBinary(this.app.vault.getAbstractFileByPath(newPath));
      return { blob: new Blob([arrayBuffer], { type: "image/png" }), newPath };
    } catch (pythonError) {
      return await this.roundImageWithCanvas(file, radius, unit);
    }
  }
  async roundImageWithPython(inputPath, outputPath, radius, unit) {
    const pythonScript = path.join(this.app.vault.configDir, "plugins", "image-rounded-frame", "round_image.py");
    const inputFile = this.app.vault.getAbstractFileByPath(inputPath);
    if (!inputFile)
      throw new Error(`File not found: ${inputPath}`);
    if (!fs.existsSync(pythonScript)) {
      throw new Error("Python script not found. Please ensure round_image.py is in the plugin directory.");
    }
    const adapter = this.app.vault.adapter;
    const vaultBase = adapter.basePath || "";
    const fullInputPath = vaultBase ? path.join(vaultBase, inputPath) : inputPath;
    const fullOutputPath = vaultBase ? path.join(vaultBase, outputPath) : outputPath;
    const outputDir = path.dirname(fullOutputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    let pythonCmd = "python3";
    try {
      await execAsync(`which python3`);
    } catch (e) {
      pythonCmd = "python";
    }
    const command = `${pythonCmd} "${pythonScript}" "${fullInputPath}" "${fullOutputPath}" ${radius} ${unit}`;
    const { stdout, stderr } = await execAsync(command, { timeout: 3e4 });
    if (stderr && !stdout.includes("SUCCESS")) {
      throw new Error(`Python error: ${stderr}`);
    }
  }
  async roundImageWithCanvas(file, radius, unit) {
    var _a, _b;
    const arrayBuffer = await this.app.vault.readBinary(file);
    const blob = new Blob([arrayBuffer]);
    const img = await this.loadImageFromBlob(blob);
    const w = img.naturalWidth;
    const h = img.naturalHeight;
    const baseDimension = Math.min(w, h);
    const maxRadius = baseDimension / 2;
    let radiusPx;
    if (unit === "percent") {
      radiusPx = radius / 100 * baseDimension;
    } else {
      radiusPx = radius;
    }
    radiusPx = Math.min(radiusPx, maxRadius);
    radiusPx = Math.max(0, radiusPx);
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, w, h);
    ctx.globalCompositeOperation = "destination-in";
    ctx.beginPath();
    this.drawRoundedRect(ctx, 0, 0, w, h, radiusPx);
    ctx.closePath();
    ctx.fill();
    const roundedBlob = await new Promise((resolve, reject) => {
      canvas.toBlob((b) => b ? resolve(b) : reject(new Error("toBlob failed")), "image/png");
    });
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const newPath = folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png`;
    return { blob: roundedBlob, newPath };
  }
  drawRoundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr);
    ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr);
    ctx.quadraticCurveTo(x, y, x + rr, y);
  }
  async loadImageFromBlob(blob) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(blob);
    });
  }
  async writeRoundedVersion(path2, blob) {
    const arrayBuffer = await blob.arrayBuffer();
    const existing = this.app.vault.getAbstractFileByPath(path2);
    if (existing) {
      await this.app.vault.modifyBinary(existing, arrayBuffer);
    } else {
      await this.app.vault.createBinary(path2, arrayBuffer);
    }
  }
  updateReference(editor, view, match, newPath) {
    var _a, _b, _c, _d;
    const originalPath = match.path;
    const currentFile = view.file;
    let finalPath = newPath;
    if (originalPath.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(newPath);
      if (newFile) {
        const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
        const newFileDir = ((_b = newFile.parent) == null ? void 0 : _b.path) || "";
        if (newFileDir === currentDir) {
          finalPath = "./" + newFile.basename + "." + newFile.extension;
        } else if (currentDir && newFileDir.startsWith(currentDir + "/")) {
          const subPath = newFileDir.substring(currentDir.length + 1);
          finalPath = "./" + subPath + "/" + newFile.basename + "." + newFile.extension;
        } else {
          const currentParts = currentDir.split("/").filter((p) => p);
          const newParts = newFileDir.split("/").filter((p) => p);
          let commonLength = 0;
          while (commonLength < currentParts.length && commonLength < newParts.length && currentParts[commonLength] === newParts[commonLength]) {
            commonLength++;
          }
          const upLevels = currentParts.length - commonLength;
          const relativeParts = newParts.slice(commonLength);
          const fileName = newFile.basename + "." + newFile.extension;
          if (upLevels === 0 && relativeParts.length === 0) {
            finalPath = "./" + fileName;
          } else {
            finalPath = "../".repeat(upLevels) + relativeParts.join("/") + "/" + fileName;
          }
        }
      }
    } else if (!originalPath.startsWith("/") && !/^[A-Za-z]:/.test(originalPath) && !originalPath.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(newPath);
      if (newFile) {
        const currentDir = ((_c = currentFile.parent) == null ? void 0 : _c.path) || "";
        const newFileDir = ((_d = newFile.parent) == null ? void 0 : _d.path) || "";
        if (newFileDir === currentDir) {
          finalPath = newFile.basename + "." + newFile.extension;
        } else if (currentDir && newFileDir.startsWith(currentDir + "/")) {
          finalPath = newFileDir.substring(currentDir.length + 1) + "/" + newFile.basename + "." + newFile.extension;
        }
      }
    }
    if (originalPath.includes("%20") || originalPath.includes(" ")) {
      finalPath = finalPath.replace(/ /g, "%20");
    }
    let replacement = "";
    switch (match.kind) {
      case "markdown":
        replacement = `![${match.alt}](${finalPath})`;
        break;
      case "wikilink":
        replacement = match.alt && match.alt !== match.path ? `![[${finalPath}|${match.alt}]]` : `![[${finalPath}]]`;
        break;
      case "html":
        replacement = `<img src="${finalPath}" alt="${match.alt}">`;
        break;
    }
    editor.replaceRange(replacement, { line: match.lineNumber, ch: match.start }, { line: match.lineNumber, ch: match.end });
  }
  resolvePreviewSrc(view, match) {
    var _a;
    const path2 = match.path;
    if (/^https?:/i.test(path2))
      return path2;
    const file = view.file;
    const resolved = this.app.metadataCache.getFirstLinkpathDest(path2, (_a = file == null ? void 0 : file.path) != null ? _a : "");
    if (resolved)
      return this.app.vault.getResourcePath(resolved);
    return path2;
  }
  storeLast(radius, unit) {
    if (!this.settings.rememberLast)
      return;
    this.settings.lastUnit = unit;
    if (unit === "percent")
      this.settings.lastPercent = radius;
    else
      this.settings.lastPx = radius;
    void this.saveSettings();
  }
  getInitialRadius() {
    const useLast = this.settings.rememberLast;
    const unit = useLast ? this.settings.lastUnit : this.settings.defaultUnit;
    const radius = unit === "percent" ? useLast ? this.settings.lastPercent : this.settings.defaultPercent : useLast ? this.settings.lastPx : this.settings.defaultPx;
    return { unit, radius };
  }
  pathsMatch(a, b) {
    const decode = (value) => {
      try {
        return decodeURIComponent(value);
      } catch (e) {
        return value;
      }
    };
    const norm = (value) => {
      const decoded = decode(value);
      return decoded.split("?")[0].replace(/\\+/g, "/").toLowerCase().replace(/^\.\//, "");
    };
    const left = norm(a);
    const right = norm(b);
    return left === right || left.endsWith(`/${right}`) || right.endsWith(`/${left}`);
  }
  escapeAttr(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};
