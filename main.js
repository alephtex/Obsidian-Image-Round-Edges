/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageRoundedFramePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultUnit: "percent",
  defaultPercent: 25,
  defaultPx: 24,
  rememberLast: true,
  lastUnit: "percent",
  lastPercent: 25,
  lastPx: 24,
  // New shadow and border defaults
  enableShadow: false,
  shadowColor: "#000000",
  shadowBlur: 10,
  shadowOffset: 5,
  enableBorder: false,
  borderColor: "#cccccc",
  borderWidth: 2
};
var RoundedFrameSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Image Rounded Frame" });
    new import_obsidian.Setting(containerEl).setName("Default unit").setDesc("Initial unit whenever you add a rounded frame.").addDropdown((dropdown) => {
      dropdown.addOption("percent", "Percent").addOption("px", "Pixels");
      dropdown.setValue(this.plugin.settings.defaultUnit);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultUnit = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default percent radius").setDesc("Used when unit is percent.").addSlider((slider) => {
      slider.setLimits(0, 100, 1).setDynamicTooltip().setValue(this.plugin.settings.defaultPercent);
      slider.onChange(async (value) => {
        this.plugin.settings.defaultPercent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default pixel radius").setDesc("Used when unit is pixels.").addText((text) => {
      text.setPlaceholder("24").setValue(String(this.plugin.settings.defaultPx)).onChange(async (value) => {
        const numeric = Number(value);
        this.plugin.settings.defaultPx = Number.isFinite(numeric) ? Math.max(0, Math.min(400, numeric)) : 0;
        text.setValue(String(this.plugin.settings.defaultPx));
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Remember last used values").setDesc("Reuse the most recent radius and unit until Obsidian restarts.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.rememberLast);
      toggle.onChange(async (value) => {
        this.plugin.settings.rememberLast = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Shadow Effects" });
    new import_obsidian.Setting(containerEl).setName("Enable shadow").setDesc("Add a shadow effect to rounded images.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableShadow);
      toggle.onChange(async (value) => {
        this.plugin.settings.enableShadow = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow color").setDesc("Color of the shadow effect.").addText((text) => {
      text.setValue(this.plugin.settings.shadowColor);
      text.onChange(async (value) => {
        this.plugin.settings.shadowColor = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow blur").setDesc("Blur radius of the shadow (0-50px).").addSlider((slider) => {
      slider.setLimits(0, 50, 1).setDynamicTooltip().setValue(this.plugin.settings.shadowBlur);
      slider.onChange(async (value) => {
        this.plugin.settings.shadowBlur = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow offset").setDesc("Offset of the shadow (0-20px).").addSlider((slider) => {
      slider.setLimits(0, 20, 1).setDynamicTooltip().setValue(this.plugin.settings.shadowOffset);
      slider.onChange(async (value) => {
        this.plugin.settings.shadowOffset = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Border Effects" });
    new import_obsidian.Setting(containerEl).setName("Enable border").setDesc("Add a border around rounded images.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableBorder);
      toggle.onChange(async (value) => {
        this.plugin.settings.enableBorder = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Border color").setDesc("Color of the border.").addText((text) => {
      text.setValue(this.plugin.settings.borderColor);
      text.onChange(async (value) => {
        this.plugin.settings.borderColor = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Border width").setDesc("Width of the border (1-10px).").addSlider((slider) => {
      slider.setLimits(1, 10, 1).setDynamicTooltip().setValue(this.plugin.settings.borderWidth);
      slider.onChange(async (value) => {
        this.plugin.settings.borderWidth = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// style-manager.ts
var CLASS_NAME = "rounded-frame-img";
var RoundedStyleManager = class {
  constructor() {
    this.seen = /* @__PURE__ */ new Set();
    this.styleEl = document.head.querySelector("#rounded-frame-style");
    if (!this.styleEl) {
      this.styleEl = document.createElement("style");
      this.styleEl.id = "rounded-frame-style";
      document.head.appendChild(this.styleEl);
      this.appendRule(`img.${CLASS_NAME}{display:inline-block;}`);
    }
  }
  ensureRule(unit, value) {
    return CLASS_NAME;
  }
  updateStyles(radius, unit, shadow, border) {
    this.currentShadow = shadow;
    this.currentBorder = border;
    while (this.styleEl.firstChild) {
      this.styleEl.removeChild(this.styleEl.firstChild);
    }
    let cssRule = `img.${CLASS_NAME} { display: inline-block;`;
    if (border == null ? void 0 : border.enabled) {
      cssRule += ` border: ${border.width}px solid ${border.color};`;
    }
    if (shadow == null ? void 0 : shadow.enabled) {
      cssRule += ` box-shadow: ${shadow.offset}px ${shadow.offset}px ${shadow.blur}px ${shadow.color};`;
    }
    cssRule += ` }`;
    this.appendRule(cssRule);
  }
  appendRule(rule) {
    this.styleEl.appendChild(document.createTextNode(`${rule}
`));
  }
};

// modal.ts
var import_obsidian2 = require("obsidian");
var RoundedFrameModal = class extends import_obsidian2.Modal {
  constructor(app, opts) {
    var _a, _b, _c, _d, _e, _f, _g;
    super(app);
    this.opts = opts;
    this.undoStack = [];
    this.redoStack = [];
    this.radius = opts.initialRadius;
    this.unit = opts.initialUnit;
    this.shadow = {
      enabled: (_a = opts.enableShadow) != null ? _a : false,
      color: (_b = opts.shadowColor) != null ? _b : "#000000",
      blur: (_c = opts.shadowBlur) != null ? _c : 10,
      offset: (_d = opts.shadowOffset) != null ? _d : 5
    };
    this.border = {
      enabled: (_e = opts.enableBorder) != null ? _e : false,
      color: (_f = opts.borderColor) != null ? _f : "#cccccc",
      width: (_g = opts.borderWidth) != null ? _g : 2
    };
    this.saveState();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rounded-frame-modal");
    contentEl.createEl("h2", { text: "Rounded frame" });
    const effectRow = contentEl.createDiv("rounded-frame-effect-row");
    const shadowToggle = effectRow.createEl("button", {
      text: "Shadow",
      attr: { "data-effect": "shadow" }
    });
    const borderToggle = effectRow.createEl("button", {
      text: "Border",
      attr: { "data-effect": "border" }
    });
    shadowToggle.classList.toggle("mod-cta", this.shadow.enabled);
    borderToggle.classList.toggle("mod-cta", this.border.enabled);
    const unitRow = contentEl.createDiv("rounded-frame-unit-row");
    const percentBtn = unitRow.createEl("button", { text: "Percent" });
    const pixelBtn = unitRow.createEl("button", { text: "Pixels" });
    let percentRadius = this.unit === "percent" ? this.radius : this.opts.defaultPercent;
    let pixelRadius = this.unit === "px" ? this.radius : this.opts.defaultPx;
    const percentSection = contentEl.createDiv("rounded-frame-section");
    const percentValue = percentSection.createSpan({ text: `${percentRadius}%` });
    const percentSlider = percentSection.createEl("input", { type: "range" });
    percentSlider.addClass("rounded-frame-slider");
    percentSlider.min = "0";
    percentSlider.max = "100";
    percentSlider.step = "1";
    percentSlider.value = String(percentRadius);
    const pixelSection = contentEl.createDiv("rounded-frame-section");
    const pixelInput = pixelSection.createEl("input", { type: "number" });
    pixelInput.addClass("rounded-frame-number");
    pixelInput.min = "0";
    pixelInput.max = "400";
    pixelInput.step = "1";
    pixelInput.value = String(pixelRadius);
    const previewContainer = contentEl.createDiv("rounded-frame-preview");
    let previewImages = [];
    const imageSources = this.opts.imageSources || (this.opts.imageSrc ? [this.opts.imageSrc] : []);
    for (const src of imageSources) {
      const img = previewContainer.createEl("img", {
        attr: { src, alt: "Preview image" }
      });
      img.addClass("rounded-frame-preview-img");
      previewImages.push(img);
    }
    const buttonRow = contentEl.createDiv("rounded-frame-button-row");
    const undoBtn = buttonRow.createEl("button", { text: "Undo" });
    const redoBtn = buttonRow.createEl("button", { text: "Redo" });
    const resetBtn = buttonRow.createEl("button", { text: "Reset" });
    const cancelBtn = buttonRow.createEl("button", { text: "Cancel" });
    const applyBtn = buttonRow.createEl("button", { text: "Apply" });
    applyBtn.addClass("mod-cta");
    undoBtn.disabled = this.undoStack.length <= 1;
    redoBtn.disabled = this.redoStack.length === 0;
    const syncUI = () => {
      if (this.unit === "percent") {
        percentSection.removeClass("rounded-frame-hidden");
        pixelSection.addClass("rounded-frame-hidden");
        percentSlider.value = String(percentRadius);
        percentValue.setText(`${percentRadius}%`);
      } else {
        pixelSection.removeClass("rounded-frame-hidden");
        percentSection.addClass("rounded-frame-hidden");
        pixelInput.value = String(pixelRadius);
      }
      for (const img of previewImages) {
        const calcRadius = () => {
          const w = img.naturalWidth || img.width || img.offsetWidth;
          const h = img.naturalHeight || img.height || img.offsetHeight;
          if (!w || !h)
            return;
          const baseDimension = Math.min(w, h);
          const maxRadius = baseDimension / 2;
          let radiusPx;
          if (this.unit === "percent") {
            radiusPx = percentRadius / 100 * baseDimension;
          } else {
            radiusPx = pixelRadius;
          }
          radiusPx = Math.min(radiusPx, maxRadius);
          img.style.borderRadius = Math.max(0, radiusPx) + "px";
          if (this.shadow.enabled) {
            img.style.boxShadow = `${this.shadow.offset}px ${this.shadow.offset}px ${this.shadow.blur}px ${this.shadow.color}`;
          } else {
            img.style.boxShadow = "";
          }
          if (this.border.enabled) {
            img.style.border = `${this.border.width}px solid ${this.border.color}`;
          } else {
            img.style.border = "";
          }
        };
        if (img.complete) {
          calcRadius();
        } else {
          img.addEventListener("load", calcRadius, { once: true });
        }
      }
    };
    const setUnit = (unit) => {
      this.unit = unit;
      this.radius = unit === "percent" ? percentRadius : pixelRadius;
      percentBtn.toggleClass("mod-cta", unit === "percent");
      pixelBtn.toggleClass("mod-cta", unit === "px");
      syncUI();
    };
    shadowToggle.addEventListener("click", () => {
      this.shadow.enabled = !this.shadow.enabled;
      shadowToggle.classList.toggle("mod-cta", this.shadow.enabled);
      this.saveState();
      syncUI();
    });
    borderToggle.addEventListener("click", () => {
      this.border.enabled = !this.border.enabled;
      borderToggle.classList.toggle("mod-cta", this.border.enabled);
      this.saveState();
      syncUI();
    });
    percentBtn.addEventListener("click", () => setUnit("percent"));
    pixelBtn.addEventListener("click", () => setUnit("px"));
    percentSlider.addEventListener("input", (evt) => {
      percentRadius = Number(evt.target.value);
      this.radius = percentRadius;
      this.saveState();
      syncUI();
    });
    pixelInput.addEventListener("input", (evt) => {
      const value = Number(evt.target.value);
      pixelRadius = this.clamp(Number.isFinite(value) ? value : 0, 0, 400);
      this.radius = pixelRadius;
      this.saveState();
      syncUI();
    });
    undoBtn.addEventListener("click", () => {
      this.undo();
      this.updateUndoRedoButtons(undoBtn, redoBtn);
      syncUI();
    });
    redoBtn.addEventListener("click", () => {
      this.redo();
      this.updateUndoRedoButtons(undoBtn, redoBtn);
      syncUI();
    });
    resetBtn.addEventListener("click", () => {
      if (this.unit === "percent") {
        percentRadius = this.opts.defaultPercent;
        this.radius = percentRadius;
      } else {
        pixelRadius = this.opts.defaultPx;
        this.radius = pixelRadius;
      }
      this.saveState();
      syncUI();
    });
    cancelBtn.addEventListener("click", () => this.close());
    applyBtn.addEventListener("click", () => {
      this.opts.onSubmit(this.radius, this.unit, this.shadow, this.border);
      this.close();
    });
    setUnit(this.unit);
  }
  onClose() {
    this.contentEl.empty();
  }
  saveState() {
    const state = {
      radius: this.radius,
      unit: this.unit,
      shadow: { ...this.shadow },
      border: { ...this.border }
    };
    this.undoStack.push(state);
    this.redoStack = [];
  }
  undo() {
    if (this.undoStack.length > 1) {
      const currentState = this.undoStack.pop();
      this.redoStack.push(currentState);
      const previousState = this.undoStack[this.undoStack.length - 1];
      this.restoreState(previousState);
    }
  }
  redo() {
    if (this.redoStack.length > 0) {
      const state = this.redoStack.pop();
      this.undoStack.push(state);
      this.restoreState(state);
    }
  }
  restoreState(state) {
    this.radius = state.radius;
    this.unit = state.unit;
    this.shadow = { ...state.shadow };
    this.border = { ...state.border };
  }
  updateUndoRedoButtons(undoBtn, redoBtn) {
    undoBtn.disabled = this.undoStack.length <= 1;
    redoBtn.disabled = this.redoStack.length === 0;
  }
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
};

// main.ts
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var ImageRoundedFramePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.style = new RoundedStyleManager();
  }
  async onload() {
    await this.loadSettings();
    this.ensureUiStyles();
    this.addSettingTab(new RoundedFrameSettingTab(this.app, this));
    await this.ensurePythonScript();
    this.addCommand({
      id: "rounded-frame-apply-visible",
      name: "Rounded frame: apply to visible images",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view)
          return false;
        const visible = this.getVisibleImages(view);
        if (checking)
          return visible.length > 0;
        if (visible.length === 0)
          return false;
        const matches = [];
        for (const img of visible) {
          const src = img.getAttribute("src") || img.getAttribute("data-src") || "";
          const m = this.locateMatchBySrc(view, src);
          if (m)
            matches.push(m);
        }
        const unique = this.uniqueMatches(matches);
        if (unique.length === 0)
          return false;
        const first = visible[0];
        const imageSources = visible.map((img) => img.getAttribute("src") || img.getAttribute("data-src") || "").filter((src) => src);
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSources,
          enableShadow: this.settings.enableShadow,
          shadowColor: this.settings.shadowColor,
          shadowBlur: this.settings.shadowBlur,
          shadowOffset: this.settings.shadowOffset,
          enableBorder: this.settings.enableBorder,
          borderColor: this.settings.borderColor,
          borderWidth: this.settings.borderWidth,
          onSubmit: (radius, unit, shadow, border) => this.applyRoundedFrameToMatches(view, unique, radius, unit, shadow, border)
        });
        modal.open();
        return true;
      }
    });
    this.addCommand({
      id: "rounded-frame-apply-all",
      name: "Rounded frame: apply to all images in note",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view)
          return false;
        const all = this.getAllMatches(view);
        if (checking)
          return all.length > 0;
        if (all.length === 0)
          return false;
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSources: [],
          // Will show generic preview for all images
          enableShadow: this.settings.enableShadow,
          shadowColor: this.settings.shadowColor,
          shadowBlur: this.settings.shadowBlur,
          shadowOffset: this.settings.shadowOffset,
          enableBorder: this.settings.enableBorder,
          borderColor: this.settings.borderColor,
          borderWidth: this.settings.borderWidth,
          onSubmit: (radius, unit, shadow, border) => this.applyRoundedFrameToMatches(view, all, radius, unit, shadow, border)
        });
        modal.open();
        return true;
      }
    });
    this.addCommand({
      id: "rounded-frame-process-subfolder",
      name: "Rounded frame: process all images in current subfolder",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view || !view.file)
          return false;
        if (checking)
          return true;
        this.processSubfolderImages(view);
        return true;
      }
    });
    this.addCommand({
      id: "rounded-frame-process-vault",
      name: "Rounded frame: process all images in vault",
      checkCallback: (checking) => {
        if (checking)
          return true;
        this.processVaultImages();
        return true;
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  ensureUiStyles() {
    if (document.head.querySelector("#rounded-frame-ui"))
      return;
    const style = document.createElement("style");
    style.id = "rounded-frame-ui";
    style.textContent = ".rounded-frame-modal{padding:20px;min-width:360px;}.rounded-frame-unit-row{display:flex;gap:8px;margin-bottom:12px;}.rounded-frame-unit-row button{flex:1;}.rounded-frame-section{margin-bottom:12px;}.rounded-frame-hidden{display:none;}.rounded-frame-slider{width:100%;}.rounded-frame-number{width:100%;}.rounded-frame-preview{text-align:center;margin:16px 0;}.rounded-frame-preview-img{max-width:220px;max-height:220px;border:2px solid var(--background-modifier-border);object-fit:contain;}.rounded-frame-button-row{display:flex;justify-content:flex-end;gap:10px;margin-top:16px;}";
    document.head.appendChild(style);
  }
  async ensurePythonScript() {
    const pythonScript = path.join(this.app.vault.configDir, "plugins", "image-rounded-frame", "round_image.py");
    const pluginDir = path.dirname(pythonScript);
    if (!fs.existsSync(pluginDir)) {
      fs.mkdirSync(pluginDir, { recursive: true });
    }
    const sourceScript = path.join(__dirname, "round_image.py");
    if (fs.existsSync(sourceScript) && !fs.existsSync(pythonScript)) {
      fs.copyFileSync(sourceScript, pythonScript);
      fs.chmodSync(pythonScript, 493);
    }
  }
  // Right-click integrations removed; command-driven flow only
  refreshMatch(editor, match) {
    var _a;
    const line = editor.getLine(match.lineNumber);
    return line.slice(match.start, match.end) === match.raw ? match : (_a = this.findMatchInLine(line, match.lineNumber, { targetSrc: match.path })) != null ? _a : null;
  }
  findMatchInLine(line, lineNumber, opts = {}) {
    var _a;
    const candidates = this.collectMatches(line, lineNumber);
    if (opts.targetSrc) {
      const matched = candidates.find((c) => this.pathsMatch(opts.targetSrc, c.path));
      if (matched)
        return matched;
    }
    if (opts.cursorCh !== void 0) {
      const matched = candidates.find((c) => opts.cursorCh >= c.start && opts.cursorCh <= c.end);
      if (matched)
        return matched;
    }
    return (_a = candidates[0]) != null ? _a : null;
  }
  locateMatchBySrc(view, src) {
    if (!src)
      return null;
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const match = this.findMatchInLine(lines[lineNumber], lineNumber, { targetSrc: src });
      if (match)
        return match;
    }
    return null;
  }
  getAllMatches(view) {
    const out = [];
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const list = this.collectMatches(lines[lineNumber], lineNumber);
      for (const m of list)
        out.push(m);
    }
    return this.uniqueMatches(out);
  }
  getVisibleImages(view) {
    const root = view.containerEl;
    const imgs = Array.from(root.querySelectorAll("img"));
    const viewportH = window.innerHeight || document.documentElement.clientHeight;
    return imgs.filter((img) => {
      const r = img.getBoundingClientRect();
      const visible = r.bottom > 0 && r.top < viewportH && r.width > 0 && r.height > 0;
      const src = img.getAttribute("src") || img.getAttribute("data-src");
      return visible && !!src;
    });
  }
  uniqueMatches(matches) {
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const m of matches) {
      const key = `${m.lineNumber}:${m.start}:${m.end}`;
      if (!seen.has(key)) {
        seen.add(key);
        out.push(m);
      }
    }
    return out;
  }
  async applyRoundedFrameToMatches(view, matches, radius, unit, shadow, border) {
    const editor = view.editor;
    const refreshed = [];
    for (const m of matches) {
      const updated = this.refreshMatch(editor, m);
      if (updated)
        refreshed.push(updated);
    }
    refreshed.sort((a, b) => {
      if (a.lineNumber !== b.lineNumber) {
        return b.lineNumber - a.lineNumber;
      }
      return b.start - a.start;
    });
    this.style.updateStyles(radius, unit, shadow, border);
    const updates = [];
    for (const m of refreshed) {
      try {
        const file = this.resolveTFile(view, m.path);
        if (!file) {
          new import_obsidian3.Notice(`Could not find file: ${m.path}`, 2e3);
          continue;
        }
        const { blob, newPath } = await this.roundImageFile(file, radius, unit);
        await this.writeRoundedVersion(newPath, blob);
        updates.push({ match: m, newPath, success: true });
      } catch (err) {
        new import_obsidian3.Notice(`Failed to round image: ${m.path} - ${err}`, 3e3);
        updates.push({ match: m, newPath: "", success: false });
      }
    }
    let positionOffset = 0;
    const sortedUpdates = updates.sort((a, b) => {
      if (a.match.lineNumber !== b.match.lineNumber) {
        return a.match.lineNumber - b.match.lineNumber;
      }
      return a.match.start - b.match.start;
    });
    for (const update of sortedUpdates) {
      if (update.success) {
        const adjustedMatch = {
          ...update.match,
          start: update.match.start + positionOffset,
          end: update.match.end + positionOffset
        };
        this.updateReference(editor, view, adjustedMatch, update.newPath);
        new import_obsidian3.Notice(`Rounded image saved: ${update.newPath}`, 1500);
        const oldLength = update.match.end - update.match.start;
        const newPath = this.getRelativePathForNote(view, update.newPath);
        const newRef = this.buildReference(update.match, newPath);
        const newLength = newRef.length;
        positionOffset += newLength - oldLength;
      }
    }
    this.storeLast(radius, unit);
  }
  async getImagesInCurrentSubfolder(view) {
    if (!view.file)
      return [];
    const currentFile = view.file;
    const currentFolder = currentFile.parent;
    if (!currentFolder)
      return [];
    const folderPath = currentFolder.path;
    const referencedImages = await this.getReferencedImagesInFolder(currentFolder);
    const physicalImages = this.getPhysicalImagesInFolder(currentFolder);
    const allImages = /* @__PURE__ */ new Map();
    for (const img of referencedImages) {
      allImages.set(img.path, img);
    }
    for (const img of physicalImages) {
      allImages.set(img.path, img);
    }
    return Array.from(allImages.values());
  }
  async getReferencedImagesInFolder(folder) {
    const referencedImages = [];
    const markdownFiles = this.getMarkdownFilesInFolder(folder);
    for (const mdFile of markdownFiles) {
      const content = await this.readFileContent(mdFile);
      if (!content)
        continue;
      const imageRefs = this.extractImageReferences(content);
      for (const imagePath of imageRefs) {
        const resolvedFile = this.resolveImageFile(imagePath, mdFile);
        if (resolvedFile && !referencedImages.some((img) => img.path === resolvedFile.path)) {
          referencedImages.push(resolvedFile);
        }
      }
    }
    return referencedImages;
  }
  getPhysicalImagesInFolder(folder) {
    const imageExtensions = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "svg"];
    const folderPath = folder.path;
    const allFiles = this.app.vault.getFiles();
    const imagesInFolder = [];
    for (const file of allFiles) {
      if (file.path.startsWith(folderPath + "/")) {
        const extension = file.extension.toLowerCase();
        if (imageExtensions.includes(extension)) {
          imagesInFolder.push(file);
        }
      }
    }
    return imagesInFolder;
  }
  getMarkdownFilesInFolder(folder) {
    const markdownFiles = [];
    const folderPath = folder.path;
    const allFiles = this.app.vault.getFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folderPath + "/") && file.extension.toLowerCase() === "md") {
        markdownFiles.push(file);
      }
    }
    return markdownFiles;
  }
  async readFileContent(file) {
    try {
      const content = await this.app.vault.read(file);
      return content;
    } catch (error) {
      console.error("Error reading file:", file.path, error);
      return null;
    }
  }
  extractImageReferences(content) {
    const imageRefs = [];
    const mdRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let mdMatch;
    while ((mdMatch = mdRegex.exec(content)) !== null) {
      imageRefs.push(mdMatch[2].trim());
    }
    const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
    let wikiMatch;
    while ((wikiMatch = wikiRegex.exec(content)) !== null) {
      imageRefs.push(wikiMatch[1].trim());
    }
    const htmlRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
    let htmlMatch;
    while ((htmlMatch = htmlRegex.exec(content)) !== null) {
      imageRefs.push(htmlMatch[1].trim());
    }
    return imageRefs;
  }
  resolveImageFile(imagePath, sourceFile) {
    var _a, _b;
    let decodedPath;
    try {
      decodedPath = decodeURIComponent(imagePath);
    } catch (error) {
      decodedPath = imagePath;
    }
    try {
      const file = this.app.vault.getAbstractFileByPath(decodedPath);
      if (file)
        return file;
    } catch (error) {
    }
    if (decodedPath.startsWith("./") || decodedPath.startsWith("../")) {
      const sourceDir = ((_a = sourceFile.parent) == null ? void 0 : _a.path) || "";
      let resolvedPath = decodedPath;
      if (decodedPath.startsWith("./")) {
        resolvedPath = sourceDir ? `${sourceDir}/${decodedPath.substring(2)}` : decodedPath.substring(2);
      } else {
        let currentDir = sourceDir;
        let relPath = decodedPath;
        while (relPath.startsWith("../")) {
          const parentDir = currentDir.substring(0, currentDir.lastIndexOf("/"));
          currentDir = parentDir || "";
          relPath = relPath.substring(3);
        }
        resolvedPath = currentDir ? `${currentDir}/${relPath}` : relPath;
      }
      try {
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        return file || null;
      } catch (error) {
      }
    }
    if (decodedPath.includes("/") && !decodedPath.startsWith("/")) {
      try {
        const file = this.app.vault.getAbstractFileByPath(decodedPath);
        if (file)
          return file;
      } catch (error) {
      }
    }
    if (!decodedPath.includes("/")) {
      const sourceDir = ((_b = sourceFile.parent) == null ? void 0 : _b.path) || "";
      const resolvedPath = sourceDir ? `${sourceDir}/${decodedPath}` : decodedPath;
      try {
        const file = this.app.vault.getAbstractFileByPath(resolvedPath);
        if (file)
          return file;
      } catch (error) {
      }
    }
    return null;
  }
  async getImagesInVault() {
    const rootFolder = this.app.vault.getRoot();
    const referencedImages = await this.getReferencedImagesInFolder(rootFolder);
    const physicalImages = this.getPhysicalImagesInFolder(rootFolder);
    const allImages = /* @__PURE__ */ new Map();
    for (const img of referencedImages) {
      allImages.set(img.path, img);
    }
    for (const img of physicalImages) {
      allImages.set(img.path, img);
    }
    return Array.from(allImages.values());
  }
  getImageFilesInFolder(folder) {
    const imageExtensions = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "svg"];
    const images = [];
    for (const item of folder.children) {
      if (item instanceof import_obsidian3.TFile) {
        const extension = item.extension.toLowerCase();
        if (imageExtensions.includes(extension)) {
          images.push(item);
        }
      }
    }
    for (const item of folder.children) {
      if (item instanceof import_obsidian3.TFolder) {
        images.push(...this.getImageFilesInFolder(item));
      }
    }
    return images;
  }
  async processSubfolderImages(view) {
    try {
      const subfolderImages = await this.getImagesInCurrentSubfolder(view);
      if (subfolderImages.length === 0) {
        new import_obsidian3.Notice("No images found in current subfolder", 2e3);
        return;
      }
      const modal = new RoundedFrameModal(this.app, {
        initialRadius: this.settings.defaultPercent,
        initialUnit: this.settings.defaultUnit,
        defaultPercent: this.settings.defaultPercent,
        defaultPx: this.settings.defaultPx,
        imageSources: [],
        // No preview for bulk operations
        enableShadow: this.settings.enableShadow,
        shadowColor: this.settings.shadowColor,
        shadowBlur: this.settings.shadowBlur,
        shadowOffset: this.settings.shadowOffset,
        enableBorder: this.settings.enableBorder,
        borderColor: this.settings.borderColor,
        borderWidth: this.settings.borderWidth,
        onSubmit: async (radius, unit, shadow, border) => {
          await this.processBulkImages(view, subfolderImages, radius, unit, shadow, border);
          new import_obsidian3.Notice(`Processed ${subfolderImages.length} images in subfolder`, 3e3);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian3.Notice("Error processing subfolder images", 3e3);
      console.error(error);
    }
  }
  async processVaultImages() {
    try {
      const vaultImages = await this.getImagesInVault();
      if (vaultImages.length === 0) {
        new import_obsidian3.Notice("No images found in vault", 2e3);
        return;
      }
      const modal = new RoundedFrameModal(this.app, {
        initialRadius: this.settings.defaultPercent,
        initialUnit: this.settings.defaultUnit,
        defaultPercent: this.settings.defaultPercent,
        defaultPx: this.settings.defaultPx,
        imageSources: [],
        // No preview for bulk operations
        enableShadow: this.settings.enableShadow,
        shadowColor: this.settings.shadowColor,
        shadowBlur: this.settings.shadowBlur,
        shadowOffset: this.settings.shadowOffset,
        enableBorder: this.settings.enableBorder,
        borderColor: this.settings.borderColor,
        borderWidth: this.settings.borderWidth,
        onSubmit: async (radius, unit, shadow, border) => {
          await this.processBulkImages(null, vaultImages, radius, unit, shadow, border);
          new import_obsidian3.Notice(`Processed ${vaultImages.length} images in vault`, 3e3);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian3.Notice("Error processing vault images", 3e3);
      console.error(error);
    }
  }
  async processBulkImages(view, imageFiles, radius, unit, shadow, border) {
    this.style.updateStyles(radius, unit, shadow, border);
    let processedCount = 0;
    const totalCount = imageFiles.length;
    for (const imageFile of imageFiles) {
      try {
        const virtualMatch = {
          lineNumber: 0,
          start: 0,
          end: imageFile.basename.length,
          path: imageFile.path,
          alt: imageFile.basename,
          raw: imageFile.basename,
          kind: "markdown"
        };
        const { blob, newPath } = await this.roundImageFile(imageFile, radius, unit);
        await this.writeRoundedVersion(newPath, blob);
        processedCount++;
        if (processedCount % 10 === 0 || processedCount === totalCount) {
          new import_obsidian3.Notice(`Processed ${processedCount}/${totalCount} images`, 1e3);
        }
      } catch (err) {
        console.error(`Failed to process image ${imageFile.path}:`, err);
      }
    }
    new import_obsidian3.Notice(`Bulk processing complete: ${processedCount}/${totalCount} images processed`, 3e3);
  }
  getRelativePathForNote(view, absolutePath) {
    var _a, _b, _c, _d;
    const originalPath = absolutePath;
    const currentFile = view.file;
    let finalPath = absolutePath;
    if (originalPath.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(absolutePath);
      if (newFile) {
        const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
        const newFileDir = ((_b = newFile.parent) == null ? void 0 : _b.path) || "";
        if (newFileDir === currentDir) {
          finalPath = "./" + newFile.basename + "." + newFile.extension;
        } else if (currentDir && newFileDir.startsWith(currentDir + "/")) {
          const subPath = newFileDir.substring(currentDir.length + 1);
          finalPath = "./" + subPath + "/" + newFile.basename + "." + newFile.extension;
        } else {
          const currentParts = currentDir.split("/").filter((p) => p);
          const newParts = newFileDir.split("/").filter((p) => p);
          let commonLength = 0;
          while (commonLength < currentParts.length && commonLength < newParts.length && currentParts[commonLength] === newParts[commonLength]) {
            commonLength++;
          }
          const upLevels = currentParts.length - commonLength;
          const relativeParts = newParts.slice(commonLength);
          const fileName = newFile.basename + "." + newFile.extension;
          if (upLevels === 0 && relativeParts.length === 0) {
            finalPath = "./" + fileName;
          } else {
            finalPath = "../".repeat(upLevels) + relativeParts.join("/") + "/" + fileName;
          }
        }
      }
    } else if (!originalPath.startsWith("/") && !/^[A-Za-z]:/.test(originalPath) && !originalPath.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(absolutePath);
      if (newFile) {
        const currentDir = ((_c = currentFile.parent) == null ? void 0 : _c.path) || "";
        const newFileDir = ((_d = newFile.parent) == null ? void 0 : _d.path) || "";
        if (newFileDir === currentDir) {
          finalPath = newFile.basename + "." + newFile.extension;
        }
      }
    }
    return finalPath;
  }
  buildReference(match, newPath) {
    if (match.kind === "markdown") {
      return `![${match.alt}](${newPath})`;
    } else if (match.kind === "wikilink") {
      return `![[${newPath}|${match.alt}]]`;
    } else {
      return `<img src="${newPath}" alt="${match.alt}">`;
    }
  }
  collectMatches(line, lineNumber) {
    var _a;
    const matches = [];
    const mdRegex = /!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)/g;
    let md;
    while ((md = mdRegex.exec(line)) !== null) {
      matches.push({
        lineNumber,
        start: md.index,
        end: md.index + md[0].length,
        path: md[2].trim(),
        alt: (md[1] || "").trim(),
        raw: md[0],
        kind: "markdown"
      });
    }
    const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
    let wiki;
    while ((wiki = wikiRegex.exec(line)) !== null) {
      const path2 = wiki[1].trim();
      const alt = (wiki[2] || wiki[1] || "").trim();
      matches.push({
        lineNumber,
        start: wiki.index,
        end: wiki.index + wiki[0].length,
        path: path2,
        alt,
        raw: wiki[0],
        kind: "wikilink"
      });
    }
    const htmlRegex = /<img\s+[^>]*>/gi;
    let tag;
    while ((tag = htmlRegex.exec(line)) !== null) {
      const raw = tag[0];
      const path2 = this.getAttr(raw, "src");
      if (!path2)
        continue;
      matches.push({
        lineNumber,
        start: tag.index,
        end: tag.index + raw.length,
        path: path2,
        alt: (_a = this.getAttr(raw, "alt")) != null ? _a : "",
        raw,
        kind: "html"
      });
    }
    return matches;
  }
  getAttr(tag, name) {
    var _a, _b;
    const attr = new RegExp(`${name}\\s*=\\s*("([^"]*)"|'([^']*)')`, "i").exec(tag);
    if (!attr)
      return null;
    return ((_b = (_a = attr[2]) != null ? _a : attr[3]) != null ? _b : "").trim();
  }
  resolveTFile(view, link) {
    var _a, _b, _c, _d;
    if (/^https?:/i.test(link))
      return null;
    let decodedLink = decodeURIComponent(link);
    decodedLink = decodedLink.replace(/^\.\//, "");
    const base = (_b = (_a = view.file) == null ? void 0 : _a.path) != null ? _b : "";
    let file = this.app.metadataCache.getFirstLinkpathDest(decodedLink, base);
    if (file)
      return file;
    file = this.app.metadataCache.getFirstLinkpathDest(decodedLink, base);
    if (file)
      return file;
    file = this.app.vault.getAbstractFileByPath(decodedLink);
    if (file)
      return file;
    if (view.file) {
      const parentPath = (_d = (_c = view.file.parent) == null ? void 0 : _c.path) != null ? _d : "";
      const fullPath = parentPath ? `${parentPath}/${decodedLink}` : decodedLink;
      file = this.app.vault.getAbstractFileByPath(fullPath);
      if (file)
        return file;
    }
    return null;
  }
  async roundImageFile(file, radius, unit) {
    var _a, _b;
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const newPath = folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png`;
    try {
      await this.roundImageWithPython(file.path, newPath, radius, unit);
      const arrayBuffer = await this.app.vault.readBinary(this.app.vault.getAbstractFileByPath(newPath));
      return { blob: new Blob([arrayBuffer], { type: "image/png" }), newPath };
    } catch (pythonError) {
      return await this.roundImageWithCanvas(file, radius, unit);
    }
  }
  async roundImageWithPython(inputPath, outputPath, radius, unit) {
    const pythonScript = path.join(this.app.vault.configDir, "plugins", "image-rounded-frame", "round_image.py");
    const inputFile = this.app.vault.getAbstractFileByPath(inputPath);
    if (!inputFile)
      throw new Error(`File not found: ${inputPath}`);
    if (!fs.existsSync(pythonScript)) {
      throw new Error("Python script not found. Please ensure round_image.py is in the plugin directory.");
    }
    const adapter = this.app.vault.adapter;
    const vaultBase = adapter.basePath || "";
    const fullInputPath = vaultBase ? path.join(vaultBase, inputPath) : inputPath;
    const fullOutputPath = vaultBase ? path.join(vaultBase, outputPath) : outputPath;
    const outputDir = path.dirname(fullOutputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    let pythonCmd = "python3";
    try {
      await execAsync(`which python3`);
    } catch (e) {
      pythonCmd = "python";
    }
    const command = `${pythonCmd} "${pythonScript}" "${fullInputPath}" "${fullOutputPath}" ${radius} ${unit}`;
    const { stdout, stderr } = await execAsync(command, { timeout: 3e4 });
    if (stderr && !stdout.includes("SUCCESS")) {
      throw new Error(`Python error: ${stderr}`);
    }
  }
  async roundImageWithCanvas(file, radius, unit) {
    var _a, _b;
    const arrayBuffer = await this.app.vault.readBinary(file);
    const blob = new Blob([arrayBuffer]);
    const img = await this.loadImageFromBlob(blob);
    const w = img.naturalWidth;
    const h = img.naturalHeight;
    const baseDimension = Math.min(w, h);
    const maxRadius = baseDimension / 2;
    let radiusPx;
    if (unit === "percent") {
      radiusPx = radius / 100 * baseDimension;
    } else {
      radiusPx = radius;
    }
    radiusPx = Math.min(radiusPx, maxRadius);
    radiusPx = Math.max(0, radiusPx);
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, w, h);
    ctx.globalCompositeOperation = "destination-in";
    ctx.beginPath();
    this.drawRoundedRect(ctx, 0, 0, w, h, radiusPx);
    ctx.closePath();
    ctx.fill();
    const roundedBlob = await new Promise((resolve, reject) => {
      canvas.toBlob((b) => b ? resolve(b) : reject(new Error("toBlob failed")), "image/png");
    });
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const newPath = folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png`;
    return { blob: roundedBlob, newPath };
  }
  drawRoundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr);
    ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr);
    ctx.quadraticCurveTo(x, y, x + rr, y);
  }
  async loadImageFromBlob(blob) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(blob);
    });
  }
  async writeRoundedVersion(path2, blob) {
    const arrayBuffer = await blob.arrayBuffer();
    const existing = this.app.vault.getAbstractFileByPath(path2);
    if (existing) {
      await this.app.vault.modifyBinary(existing, arrayBuffer);
    } else {
      await this.app.vault.createBinary(path2, arrayBuffer);
    }
  }
  updateReference(editor, view, match, newPath) {
    const finalPath = this.getRelativePathForNote(view, newPath);
    const originalPath = match.path;
    let processedPath = finalPath;
    if (originalPath.includes("%20") || originalPath.includes(" ")) {
      processedPath = finalPath.replace(/ /g, "%20");
    }
    const replacement = this.buildReference(match, processedPath);
    editor.replaceRange(replacement, { line: match.lineNumber, ch: match.start }, { line: match.lineNumber, ch: match.end });
  }
  resolvePreviewSrc(view, match) {
    var _a;
    const path2 = match.path;
    if (/^https?:/i.test(path2))
      return path2;
    const file = view.file;
    const resolved = this.app.metadataCache.getFirstLinkpathDest(path2, (_a = file == null ? void 0 : file.path) != null ? _a : "");
    if (resolved)
      return this.app.vault.getResourcePath(resolved);
    return path2;
  }
  storeLast(radius, unit) {
    if (!this.settings.rememberLast)
      return;
    this.settings.lastUnit = unit;
    if (unit === "percent")
      this.settings.lastPercent = radius;
    else
      this.settings.lastPx = radius;
    void this.saveSettings();
  }
  getInitialRadius() {
    const useLast = this.settings.rememberLast;
    const unit = useLast ? this.settings.lastUnit : this.settings.defaultUnit;
    const radius = unit === "percent" ? useLast ? this.settings.lastPercent : this.settings.defaultPercent : useLast ? this.settings.lastPx : this.settings.defaultPx;
    return { unit, radius };
  }
  pathsMatch(a, b) {
    const decode = (value) => {
      try {
        return decodeURIComponent(value);
      } catch (e) {
        return value;
      }
    };
    const norm = (value) => {
      const decoded = decode(value);
      return decoded.split("?")[0].replace(/\\+/g, "/").toLowerCase().replace(/^\.\//, "");
    };
    const left = norm(a);
    const right = norm(b);
    return left === right || left.endsWith(`/${right}`) || right.endsWith(`/${left}`);
  }
  escapeAttr(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};
