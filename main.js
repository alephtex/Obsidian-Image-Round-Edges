/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageRoundedFramePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultUnit: "percent",
  defaultPercent: 25,
  defaultPx: 24,
  rememberLast: true,
  lastUnit: "percent",
  lastPercent: 25,
  lastPx: 24,
  // New shadow and border defaults
  enableShadow: false,
  shadowColor: "#000000",
  shadowBlur: 10,
  shadowOffset: 5,
  enableBorder: false,
  borderColor: "#cccccc",
  borderWidth: 2,
  borderStyle: "solid",
  debugMode: false,
  watchMode: false,
  watchFolders: "",
  dualImageSystem: false
};
var RoundedFrameSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Image Rounded Frame" });
    containerEl.createEl("h3", { text: "General & Safety" });
    new import_obsidian.Setting(containerEl).setName("Dual Image System").setDesc("If enabled, creates a new file (e.g., image-rounded.png). If disabled (default), overwrites the original file.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.dualImageSystem);
      toggle.onChange(async (value) => {
        this.plugin.settings.dualImageSystem = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable verbose logging to debug issues. Logs will be written to the developer console and a log file.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode);
      toggle.onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Default Appearance" });
    new import_obsidian.Setting(containerEl).setName("Default unit").setDesc("Initial unit whenever you add a rounded frame.").addDropdown((dropdown) => {
      dropdown.addOption("percent", "Percent").addOption("px", "Pixels");
      dropdown.setValue(this.plugin.settings.defaultUnit);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultUnit = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default percent radius").setDesc("Used when unit is percent.").addSlider((slider) => {
      slider.setLimits(0, 100, 1).setDynamicTooltip().setValue(this.plugin.settings.defaultPercent);
      slider.onChange(async (value) => {
        this.plugin.settings.defaultPercent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default pixel radius").setDesc("Used when unit is pixels.").addText((text) => {
      text.setPlaceholder("24").setValue(String(this.plugin.settings.defaultPx)).onChange(async (value) => {
        const numeric = Number(value);
        this.plugin.settings.defaultPx = Number.isFinite(numeric) ? Math.max(0, Math.min(400, numeric)) : 0;
        text.setValue(String(this.plugin.settings.defaultPx));
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Remember last used values").setDesc("Reuse the most recent radius and unit until Obsidian restarts.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.rememberLast);
      toggle.onChange(async (value) => {
        this.plugin.settings.rememberLast = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Shadow Effects" });
    new import_obsidian.Setting(containerEl).setName("Enable shadow").setDesc("Add a shadow effect to rounded images.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableShadow);
      toggle.onChange(async (value) => {
        this.plugin.settings.enableShadow = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow color").setDesc("Color of the shadow effect.").addText((text) => {
      text.setValue(this.plugin.settings.shadowColor);
      text.onChange(async (value) => {
        this.plugin.settings.shadowColor = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow blur").setDesc("Blur radius of the shadow (0-50px).").addSlider((slider) => {
      slider.setLimits(0, 50, 1).setDynamicTooltip().setValue(this.plugin.settings.shadowBlur);
      slider.onChange(async (value) => {
        this.plugin.settings.shadowBlur = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Shadow offset").setDesc("Offset of the shadow (0-20px).").addSlider((slider) => {
      slider.setLimits(0, 20, 1).setDynamicTooltip().setValue(this.plugin.settings.shadowOffset);
      slider.onChange(async (value) => {
        this.plugin.settings.shadowOffset = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Border Effects" });
    new import_obsidian.Setting(containerEl).setName("Enable border").setDesc("Add a border around rounded images.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableBorder);
      toggle.onChange(async (value) => {
        this.plugin.settings.enableBorder = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Border color").setDesc("Color of the border.").addText((text) => {
      text.setValue(this.plugin.settings.borderColor);
      text.onChange(async (value) => {
        this.plugin.settings.borderColor = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Border width").setDesc("Width of the border (1-10px).").addSlider((slider) => {
      slider.setLimits(1, 10, 1).setDynamicTooltip().setValue(this.plugin.settings.borderWidth);
      slider.onChange(async (value) => {
        this.plugin.settings.borderWidth = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Border style").setDesc("Style of the border.").addDropdown((dropdown) => {
      dropdown.addOption("solid", "Solid");
      dropdown.addOption("dashed", "Dashed");
      dropdown.addOption("dotted", "Dotted");
      dropdown.setValue(this.plugin.settings.borderStyle);
      dropdown.onChange(async (value) => {
        this.plugin.settings.borderStyle = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Watch Mode" });
    new import_obsidian.Setting(containerEl).setName("Enable Watch Mode").setDesc("Automatically apply rounding to new images added to your vault.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.watchMode);
      toggle.onChange(async (value) => {
        this.plugin.settings.watchMode = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Watched folders").setDesc('Comma-separated list of folders to watch (e.g., "attachments, photos"). Leave empty to watch entire vault.').addText((text) => {
      text.setPlaceholder("attachments, images").setValue(this.plugin.settings.watchFolders).onChange(async (value) => {
        this.plugin.settings.watchFolders = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// style-manager.ts
var CLASS_NAME = "rounded-frame-img";
var RoundedStyleManager = class {
  constructor() {
    this.seen = /* @__PURE__ */ new Set();
    this.styleEl = document.head.querySelector("#rounded-frame-style");
    if (!this.styleEl) {
      this.styleEl = document.createElement("style");
      this.styleEl.id = "rounded-frame-style";
      document.head.appendChild(this.styleEl);
      this.appendRule(`img.${CLASS_NAME}{display:inline-block;}`);
    }
  }
  ensureRule(unit, value) {
    return CLASS_NAME;
  }
  updateStyles(radius, unit, shadow, border) {
    this.currentShadow = shadow;
    this.currentBorder = border;
    while (this.styleEl.firstChild) {
      this.styleEl.removeChild(this.styleEl.firstChild);
    }
    let cssRule = `img.${CLASS_NAME} { display: inline-block;`;
    if (border == null ? void 0 : border.enabled) {
      cssRule += ` border: ${border.width}px solid ${border.color};`;
    }
    if (shadow == null ? void 0 : shadow.enabled) {
      cssRule += ` box-shadow: ${shadow.offset}px ${shadow.offset}px ${shadow.blur}px ${shadow.color};`;
    }
    cssRule += ` }`;
    this.appendRule(cssRule);
  }
  appendRule(rule) {
    this.styleEl.appendChild(document.createTextNode(`${rule}
`));
  }
};

// modal.ts
var import_obsidian2 = require("obsidian");
var RoundedFrameModal = class extends import_obsidian2.Modal {
  constructor(app, opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super(app);
    this.opts = opts;
    this.undoStack = [];
    this.redoStack = [];
    this.radius = opts.initialRadius;
    this.unit = opts.initialUnit;
    this.shadow = {
      enabled: (_a = opts.enableShadow) != null ? _a : false,
      color: (_b = opts.shadowColor) != null ? _b : "#000000",
      blur: (_c = opts.shadowBlur) != null ? _c : 10,
      offset: (_d = opts.shadowOffset) != null ? _d : 5
    };
    this.border = {
      enabled: (_e = opts.enableBorder) != null ? _e : false,
      color: (_f = opts.borderColor) != null ? _f : "#cccccc",
      width: (_g = opts.borderWidth) != null ? _g : 2,
      style: (_h = opts.borderStyle) != null ? _h : "solid"
    };
    this.saveState();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rounded-frame-modal");
    contentEl.createEl("h2", { text: "Rounded frame" });
    const effectRow = contentEl.createDiv("rounded-frame-effect-row");
    const shadowToggle = effectRow.createEl("button", {
      text: "Shadow",
      attr: { "data-effect": "shadow" }
    });
    const borderToggle = effectRow.createEl("button", {
      text: "Border",
      attr: { "data-effect": "border" }
    });
    shadowToggle.classList.toggle("mod-cta", this.shadow.enabled);
    borderToggle.classList.toggle("mod-cta", this.border.enabled);
    const shadowSection = contentEl.createDiv("rounded-frame-shadow-section");
    shadowSection.style.display = this.shadow.enabled ? "block" : "none";
    const shadowColorRow = shadowSection.createDiv("rounded-frame-control-row");
    shadowColorRow.createSpan({ text: "Shadow Color: " });
    const shadowColorInput = shadowColorRow.createEl("input", { type: "color" });
    shadowColorInput.value = this.shadow.color;
    const shadowBlurRow = shadowSection.createDiv("rounded-frame-control-row");
    shadowBlurRow.createSpan({ text: "Blur: " });
    const shadowBlurValue = shadowBlurRow.createSpan({ text: `${this.shadow.blur}px` });
    const shadowBlurSlider = shadowBlurRow.createEl("input", { type: "range" });
    shadowBlurSlider.min = "0";
    shadowBlurSlider.max = "50";
    shadowBlurSlider.step = "1";
    shadowBlurSlider.value = String(this.shadow.blur);
    const shadowOffsetRow = shadowSection.createDiv("rounded-frame-control-row");
    shadowOffsetRow.createSpan({ text: "Offset: " });
    const shadowOffsetValue = shadowOffsetRow.createSpan({ text: `${this.shadow.offset}px` });
    const shadowOffsetSlider = shadowOffsetRow.createEl("input", { type: "range" });
    shadowOffsetSlider.min = "0";
    shadowOffsetSlider.max = "20";
    shadowOffsetSlider.step = "1";
    shadowOffsetSlider.value = String(this.shadow.offset);
    const borderSection = contentEl.createDiv("rounded-frame-border-section");
    borderSection.style.display = this.border.enabled ? "block" : "none";
    const borderColorRow = borderSection.createDiv("rounded-frame-control-row");
    borderColorRow.createSpan({ text: "Border Color: " });
    const borderColorInput = borderColorRow.createEl("input", { type: "color" });
    borderColorInput.value = this.border.color;
    const borderWidthRow = borderSection.createDiv("rounded-frame-control-row");
    borderWidthRow.createSpan({ text: "Width: " });
    const borderWidthValue = borderWidthRow.createSpan({ text: `${this.border.width}px` });
    const borderWidthSlider = borderWidthRow.createEl("input", { type: "range" });
    borderWidthSlider.min = "1";
    borderWidthSlider.max = "10";
    borderWidthSlider.step = "1";
    borderWidthSlider.value = String(this.border.width);
    const borderStyleRow = borderSection.createDiv("rounded-frame-control-row");
    borderStyleRow.createSpan({ text: "Style: " });
    const borderStyleSelect = borderStyleRow.createEl("select");
    const solidOption = borderStyleSelect.createEl("option", { text: "Solid", value: "solid" });
    const dashedOption = borderStyleSelect.createEl("option", { text: "Dashed", value: "dashed" });
    const dottedOption = borderStyleSelect.createEl("option", { text: "Dotted", value: "dotted" });
    borderStyleSelect.value = this.border.style;
    const unitRow = contentEl.createDiv("rounded-frame-unit-row");
    const percentBtn = unitRow.createEl("button", { text: "Percent" });
    const pixelBtn = unitRow.createEl("button", { text: "Pixels" });
    let percentRadius = this.unit === "percent" ? this.radius : this.opts.defaultPercent;
    let pixelRadius = this.unit === "px" ? this.radius : this.opts.defaultPx;
    const percentSection = contentEl.createDiv("rounded-frame-section");
    const percentValue = percentSection.createSpan({ text: `${percentRadius}%` });
    const percentSlider = percentSection.createEl("input", { type: "range" });
    percentSlider.addClass("rounded-frame-slider");
    percentSlider.min = "0";
    percentSlider.max = "100";
    percentSlider.step = "1";
    percentSlider.value = String(percentRadius);
    const pixelSection = contentEl.createDiv("rounded-frame-section");
    const pixelInput = pixelSection.createEl("input", { type: "number" });
    pixelInput.addClass("rounded-frame-number");
    pixelInput.min = "0";
    pixelInput.max = "400";
    pixelInput.step = "1";
    pixelInput.value = String(pixelRadius);
    const previewContainer = contentEl.createDiv("rounded-frame-preview");
    let previewImages = [];
    let previewThumbnail = null;
    const imageSources = this.opts.imageSources || (this.opts.imageSrc ? [this.opts.imageSrc] : []);
    if (imageSources.length > 0) {
      const firstImageSrc = imageSources[0];
      const thumbnailContainer = previewContainer.createDiv("rounded-frame-thumbnail-container");
      thumbnailContainer.createEl("h4", { text: "Live Preview (Low-Res)" });
      previewThumbnail = thumbnailContainer.createEl("img", {
        attr: {
          src: firstImageSrc,
          alt: "Preview thumbnail",
          style: "max-width: 150px; max-height: 150px; border: 1px solid var(--background-modifier-border);"
        }
      });
      previewThumbnail.addClass("rounded-frame-preview-thumbnail");
      const imagesContainer = previewContainer.createDiv("rounded-frame-images-container");
      imagesContainer.createEl("h4", { text: "Images to Process" });
      for (const src of imageSources.slice(0, 4)) {
        const img = imagesContainer.createEl("img", {
          attr: { src, alt: "Preview image" }
        });
        img.addClass("rounded-frame-preview-img");
        previewImages.push(img);
      }
      if (imageSources.length > 4) {
        imagesContainer.createEl("span", {
          text: `... and ${imageSources.length - 4} more images`,
          attr: { style: "font-size: 0.8em; color: var(--text-muted);" }
        });
      }
    }
    const buttonRow = contentEl.createDiv("rounded-frame-button-row");
    const undoBtn = buttonRow.createEl("button", { text: "Undo" });
    const redoBtn = buttonRow.createEl("button", { text: "Redo" });
    const resetBtn = buttonRow.createEl("button", { text: "Reset" });
    const cancelBtn = buttonRow.createEl("button", { text: "Cancel" });
    const applyBtn = buttonRow.createEl("button", { text: "Apply" });
    applyBtn.addClass("mod-cta");
    undoBtn.disabled = this.undoStack.length <= 1;
    redoBtn.disabled = this.redoStack.length === 0;
    const syncUI = () => {
      if (this.unit === "percent") {
        percentSection.removeClass("rounded-frame-hidden");
        pixelSection.addClass("rounded-frame-hidden");
        percentSlider.value = String(percentRadius);
        percentValue.setText(`${percentRadius}%`);
      } else {
        pixelSection.removeClass("rounded-frame-hidden");
        percentSection.addClass("rounded-frame-hidden");
        pixelInput.value = String(pixelRadius);
      }
      for (const img of previewImages) {
        const calcRadius = () => {
          const w = img.naturalWidth || img.width || img.offsetWidth;
          const h = img.naturalHeight || img.height || img.offsetHeight;
          if (!w || !h)
            return;
          const baseDimension = Math.min(w, h);
          const maxRadius = baseDimension / 2;
          let radiusPx;
          if (this.unit === "percent") {
            radiusPx = percentRadius / 100 * baseDimension;
          } else {
            radiusPx = pixelRadius;
          }
          radiusPx = Math.min(radiusPx, maxRadius);
          img.style.borderRadius = Math.max(0, radiusPx) + "px";
          if (this.shadow.enabled) {
            img.style.boxShadow = `${this.shadow.offset}px ${this.shadow.offset}px ${this.shadow.blur}px ${this.shadow.color}`;
          } else {
            img.style.boxShadow = "";
          }
          if (this.border.enabled) {
            img.style.border = `${this.border.width}px ${this.border.style} ${this.border.color}`;
          } else {
            img.style.border = "";
          }
        };
        if (img.complete) {
          calcRadius();
        } else {
          img.addEventListener("load", calcRadius, { once: true });
        }
      }
      if (previewThumbnail) {
        const updateThumbnail = () => {
          const w = previewThumbnail.naturalWidth || previewThumbnail.width || previewThumbnail.offsetWidth;
          const h = previewThumbnail.naturalHeight || previewThumbnail.height || previewThumbnail.offsetHeight;
          if (!w || !h)
            return;
          const baseDimension = Math.min(w, h);
          const maxRadius = baseDimension / 2;
          let radiusPx;
          if (this.unit === "percent") {
            radiusPx = percentRadius / 100 * baseDimension;
          } else {
            radiusPx = pixelRadius;
          }
          radiusPx = Math.min(radiusPx, maxRadius);
          previewThumbnail.style.borderRadius = Math.max(0, radiusPx) + "px";
          if (this.shadow.enabled) {
            previewThumbnail.style.boxShadow = `${this.shadow.offset}px ${this.shadow.offset}px ${this.shadow.blur}px ${this.shadow.color}`;
          } else {
            previewThumbnail.style.boxShadow = "";
          }
          if (this.border.enabled) {
            previewThumbnail.style.border = `${this.border.width}px ${this.border.style} ${this.border.color}`;
          } else {
            previewThumbnail.style.border = "1px solid var(--background-modifier-border)";
          }
        };
        if (previewThumbnail.complete) {
          updateThumbnail();
        } else {
          previewThumbnail.addEventListener("load", updateThumbnail, { once: true });
        }
      }
    };
    const setUnit = (unit) => {
      this.unit = unit;
      this.radius = unit === "percent" ? percentRadius : pixelRadius;
      percentBtn.toggleClass("mod-cta", unit === "percent");
      pixelBtn.toggleClass("mod-cta", unit === "px");
      syncUI();
    };
    shadowToggle.addEventListener("click", () => {
      this.shadow.enabled = !this.shadow.enabled;
      shadowToggle.classList.toggle("mod-cta", this.shadow.enabled);
      shadowSection.style.display = this.shadow.enabled ? "block" : "none";
      this.saveState();
      syncUI();
    });
    borderToggle.addEventListener("click", () => {
      this.border.enabled = !this.border.enabled;
      borderToggle.classList.toggle("mod-cta", this.border.enabled);
      borderSection.style.display = this.border.enabled ? "block" : "none";
      this.saveState();
      syncUI();
    });
    shadowColorInput.addEventListener("input", (evt) => {
      this.shadow.color = evt.target.value;
      this.saveState();
      syncUI();
    });
    shadowBlurSlider.addEventListener("input", (evt) => {
      this.shadow.blur = Number(evt.target.value);
      shadowBlurValue.setText(`${this.shadow.blur}px`);
      this.saveState();
      syncUI();
    });
    shadowOffsetSlider.addEventListener("input", (evt) => {
      this.shadow.offset = Number(evt.target.value);
      shadowOffsetValue.setText(`${this.shadow.offset}px`);
      this.saveState();
      syncUI();
    });
    borderColorInput.addEventListener("input", (evt) => {
      this.border.color = evt.target.value;
      this.saveState();
      syncUI();
    });
    borderWidthSlider.addEventListener("input", (evt) => {
      this.border.width = Number(evt.target.value);
      borderWidthValue.setText(`${this.border.width}px`);
      this.saveState();
      syncUI();
    });
    borderStyleSelect.addEventListener("change", (evt) => {
      this.border.style = evt.target.value;
      this.saveState();
      syncUI();
    });
    percentBtn.addEventListener("click", () => setUnit("percent"));
    pixelBtn.addEventListener("click", () => setUnit("px"));
    percentSlider.addEventListener("input", (evt) => {
      percentRadius = Number(evt.target.value);
      this.radius = percentRadius;
      this.saveState();
      syncUI();
    });
    pixelInput.addEventListener("input", (evt) => {
      const value = Number(evt.target.value);
      pixelRadius = this.clamp(Number.isFinite(value) ? value : 0, 0, 400);
      this.radius = pixelRadius;
      this.saveState();
      syncUI();
    });
    undoBtn.addEventListener("click", () => {
      this.undo();
      this.updateUndoRedoButtons(undoBtn, redoBtn);
      syncUI();
    });
    redoBtn.addEventListener("click", () => {
      this.redo();
      this.updateUndoRedoButtons(undoBtn, redoBtn);
      syncUI();
    });
    resetBtn.addEventListener("click", () => {
      if (this.unit === "percent") {
        percentRadius = this.opts.defaultPercent;
        this.radius = percentRadius;
      } else {
        pixelRadius = this.opts.defaultPx;
        this.radius = pixelRadius;
      }
      this.saveState();
      syncUI();
    });
    cancelBtn.addEventListener("click", () => this.close());
    applyBtn.addEventListener("click", () => {
      this.opts.onSubmit(this.radius, this.unit, this.shadow, this.border);
      this.close();
    });
    setUnit(this.unit);
  }
  onClose() {
    this.contentEl.empty();
  }
  saveState() {
    const state = {
      radius: this.radius,
      unit: this.unit,
      shadow: { ...this.shadow },
      border: { ...this.border }
    };
    this.undoStack.push(state);
    this.redoStack = [];
  }
  undo() {
    if (this.undoStack.length > 1) {
      const currentState = this.undoStack.pop();
      this.redoStack.push(currentState);
      const previousState = this.undoStack[this.undoStack.length - 1];
      this.restoreState(previousState);
    }
  }
  redo() {
    if (this.redoStack.length > 0) {
      const state = this.redoStack.pop();
      this.undoStack.push(state);
      this.restoreState(state);
    }
  }
  restoreState(state) {
    this.radius = state.radius;
    this.unit = state.unit;
    this.shadow = { ...state.shadow };
    this.border = { ...state.border };
  }
  updateUndoRedoButtons(undoBtn, redoBtn) {
    undoBtn.disabled = this.undoStack.length <= 1;
    redoBtn.disabled = this.redoStack.length === 0;
  }
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
};

// main.ts
var SUPPORTED_EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp"];
var PY_ROUND_IMAGE = `#!/usr/bin/env python3
# 1. Load image from input path
# 2. Calculate symmetric border radius based on smaller dimension
# 3. Create rounded corners mask with transparency
# 4. Apply shadow effect if enabled
# 5. Apply border effect if enabled
# 6. Composite all effects
# 7. Save result as PNG with transparency

import sys
from PIL import Image, ImageDraw, ImageFilter
import math

def hex_to_rgb(hex_color):
    """Convert hex color string to RGB tuple"""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

def apply_effects(input_path, output_path, radius_value, unit,
                  shadow_enabled=False, shadow_color="#000000", shadow_blur=10, shadow_offset=5,
                  border_enabled=False, border_color="#cccccc", border_width=2, border_style="solid"):
    # Load image
    img = Image.open(input_path).convert("RGBA")
    w, h = img.size

    # Calculate radius
    base_dimension = min(w, h)
    max_radius = base_dimension / 2

    if unit == 'percent':
        radius_px = (radius_value / 100) * base_dimension
    else:
        radius_px = radius_value

    radius_px = min(radius_px, max_radius)
    radius_px = max(0, radius_px)

    # Create the final canvas (larger if shadow or border is enabled)
    shadow_padding = shadow_blur + shadow_offset + 10 if shadow_enabled else 0
    border_padding = border_width if border_enabled else 0
    canvas_padding = shadow_padding + border_padding
    canvas_w = w + canvas_padding * 2
    canvas_h = h + canvas_padding * 2
    canvas = Image.new('RGBA', (0 + canvas_w, 0 + canvas_h), (0, 0, 0, 0))

    # Position of original image on canvas (centered with padding)
    img_x = canvas_padding
    img_y = canvas_padding

    # Create mask for rounded corners
    mask = Image.new('L', (w, h), 0)
    draw = ImageDraw.Draw(mask)
    draw.rounded_rectangle([(0, 0), (w, h)], radius=int(radius_px), fill=255)

    # Apply rounded corners to image
    rounded_img = Image.new('RGBA', (w, h), (0, 0, 0, 0))
    rounded_img.paste(img, (0, 0), mask)

    # Apply shadow if enabled
    if shadow_enabled:
        # Create shadow
        shadow = Image.new('RGBA', (w, h), hex_to_rgb(shadow_color) + (255,))
        shadow.putalpha(mask)

        # Apply blur to shadow
        shadow = shadow.filter(ImageFilter.GaussianBlur(shadow_blur))

        # Position shadow on canvas (accounting for border padding)
        shadow_x = img_x + shadow_offset
        shadow_y = img_y + shadow_offset
        canvas.paste(shadow, (shadow_x, shadow_y), shadow)

    # First, paste the rounded image
    canvas.paste(rounded_img, (img_x, img_y), mask)

    # Apply border AFTER rounding if enabled (so it appears outside the rounded corners)
    if border_enabled:
        # Create border on the full canvas size
        border_canvas = Image.new('RGBA', (canvas_w, canvas_h), (0, 0, 0, 0))
        border_draw = ImageDraw.Draw(border_canvas)

        # Calculate border position (outside the rounded image area)
        border_x = img_x - border_width
        border_y = img_y - border_width
        border_w = w + border_width * 2
        border_h = h + border_width * 2

        # Draw the outer border shape (larger rounded rectangle)
        if border_style == "solid":
            border_draw.rounded_rectangle([border_x, border_y, border_x + border_w, border_y + border_h],
                                        radius=int(radius_px + border_width), fill=hex_to_rgb(border_color) + (255,))
        elif border_style == "dashed":
            # For dashed, we'll draw multiple rounded rectangles with gaps
            # This is a simplified dashed implementation
            dash_length = border_width * 3
            gap_length = border_width * 2
            for i in range(0, int(border_w + border_h), dash_length + gap_length):
                # Draw dashes along the perimeter (simplified)
                if i < border_w:
                    # Top dash
                    border_draw.rounded_rectangle([border_x + i, border_y, border_x + min(i + dash_length, border_w), border_y + border_width],
                                                radius=max(0, int(radius_px + border_width) - i) if i < radius_px + border_width else 0,
                                                fill=hex_to_rgb(border_color) + (255,))
                # Add more complex dashed logic for full perimeter if needed
        else:  # dotted - similar to dashed but smaller
            dot_length = border_width
            gap_length = border_width * 2
            for i in range(0, int(border_w + border_h), dot_length + gap_length):
                if i < border_w:
                    border_draw.rounded_rectangle([border_x + i, border_y, border_x + min(i + dot_length, border_w), border_y + border_width],
                                                radius=max(0, int(radius_px + border_width) - i) if i < radius_px + border_width else 0,
                                                fill=hex_to_rgb(border_color) + (255,))

        # Create mask for the inner area (where the rounded image is) to cut out from border
        inner_mask = Image.new('L', (canvas_w, canvas_h), 0)
        inner_draw = ImageDraw.Draw(inner_mask)
        inner_draw.rounded_rectangle([img_x, img_y, img_x + w, img_y + h], radius=int(radius_px), fill=255)

        # Apply the inner mask to remove border from inside the rounded image area
        border_canvas.putalpha(Image.composite(Image.new('L', (canvas_w, canvas_h), 255), Image.new('L', (canvas_w, canvas_h), 0), inner_mask))

        # Composite border onto canvas
        canvas = Image.alpha_composite(canvas, border_canvas)

    # 8. Auto-crop to remove unnecessary transparent whitespace
    # This ensures the most outer visible pixel is the image edge
    bbox = canvas.getbbox()
    if bbox:
        canvas = canvas.crop(bbox)

    # Save as PNG
    canvas.save(output_path, 'PNG')
    return True

def round_image(input_path, output_path, radius_value, unit):
    # Legacy function for backward compatibility
    return apply_effects(input_path, output_path, radius_value, unit)

if __name__ == '__main__':
    # Support both old and new argument formats for backward compatibility
    if len(sys.argv) == 5:
        # Legacy format: input_path, output_path, radius_value, unit
        input_path = sys.argv[1]
        output_path = sys.argv[2]
        radius_value = float(sys.argv[3])
        unit = sys.argv[4]

        try:
            round_image(input_path, output_path, radius_value, unit)
            print("SUCCESS")
        except Exception as e:
            print(f"ERROR: {e}", file=sys.stderr)
            sys.exit(1)
    elif len(sys.argv) >= 13:
        # New format with effects: input_path, output_path, radius_value, unit,
        # shadow_enabled, shadow_color, shadow_blur, shadow_offset,
        # border_enabled, border_color, border_width, border_style
        input_path = sys.argv[1]
        output_path = sys.argv[2]
        radius_value = float(sys.argv[3])
        unit = sys.argv[4]
        shadow_enabled = sys.argv[5].lower() == 'true'
        shadow_color = sys.argv[6]
        shadow_blur = int(sys.argv[7])
        shadow_offset = int(sys.argv[8])
        border_enabled = sys.argv[9].lower() == 'true'
        border_color = sys.argv[10]
        border_width = int(sys.argv[11])
        border_style = sys.argv[12]

        try:
            apply_effects(input_path, output_path, radius_value, unit,
                         shadow_enabled, shadow_color, shadow_blur, shadow_offset,
                         border_enabled, border_color, border_width, border_style)
            print("SUCCESS")
        except Exception as e:
            print(f"ERROR: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        print("ERROR: Invalid number of arguments", file=sys.stderr)
        sys.exit(1)
`;
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var PromiseQueue = class {
  constructor(concurrency) {
    this.current = 0;
    this.queue = [];
    this.concurrency = concurrency;
  }
  add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (e) {
          reject(e);
        }
      });
      this.next();
    });
  }
  next() {
    if (this.current >= this.concurrency || this.queue.length === 0)
      return;
    this.current++;
    const task = this.queue.shift();
    if (task) {
      task().finally(() => {
        this.current--;
        this.next();
      });
    }
  }
};
var ImageRoundedFramePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.style = new RoundedStyleManager();
    this.lastAction = null;
    this.BACKUP_FOLDER = ".obsidian-image-round-edges-backups";
    this.progressPopup = null;
    this.DEBUG_LOG_PATH = "image-rounded-frame-debug.log";
    this.recentlyProcessed = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.ensureUiStyles();
    this.addSettingTab(new RoundedFrameSettingTab(this.app, this));
    await this.ensurePythonScript();
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (this.settings.watchMode && file instanceof import_obsidian3.TFile) {
          this.handleFileCreated(file);
        }
      })
    );
    this.addCommand({
      id: "rounded-frame-apply-visible",
      name: "Rounded frame: apply to visible images",
      callback: () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view) {
          new import_obsidian3.Notice("Open a note to use this command", 2e3);
          return;
        }
        const visible = this.getVisibleImages(view);
        if (visible.length === 0) {
          new import_obsidian3.Notice("No visible images found in the active note", 2e3);
          return;
        }
        const matches = [];
        for (const img of visible) {
          const src = img.getAttribute("src") || img.getAttribute("data-src") || "";
          const m = this.locateMatchBySrc(view, src);
          if (m)
            matches.push(m);
        }
        const unique = this.uniqueMatches(matches);
        if (unique.length === 0) {
          new import_obsidian3.Notice("Could not resolve image references in this note", 2e3);
          return;
        }
        const imageSources = visible.map((img) => img.getAttribute("src") || img.getAttribute("data-src") || "").filter((src) => src);
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSources,
          enableShadow: this.settings.enableShadow,
          shadowColor: this.settings.shadowColor,
          shadowBlur: this.settings.shadowBlur,
          shadowOffset: this.settings.shadowOffset,
          enableBorder: this.settings.enableBorder,
          borderColor: this.settings.borderColor,
          borderWidth: this.settings.borderWidth,
          borderStyle: this.settings.borderStyle,
          onSubmit: (radius, unit, shadow, border) => this.applyRoundedFrameToMatches(view, unique, radius, unit, shadow, border)
        });
        modal.open();
      }
    });
    this.addCommand({
      id: "rounded-frame-apply-all",
      name: "Rounded frame: apply to all images in note",
      callback: () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view) {
          new import_obsidian3.Notice("Open a note to use this command", 2e3);
          return;
        }
        const all = this.getAllMatches(view);
        if (all.length === 0) {
          new import_obsidian3.Notice("No image references found in this note", 2e3);
          return;
        }
        const initial = this.getInitialRadius();
        const modal = new RoundedFrameModal(this.app, {
          initialRadius: initial.radius,
          initialUnit: initial.unit,
          defaultPercent: this.settings.defaultPercent,
          defaultPx: this.settings.defaultPx,
          imageSources: [],
          // Will show generic preview for all images
          enableShadow: this.settings.enableShadow,
          shadowColor: this.settings.shadowColor,
          shadowBlur: this.settings.shadowBlur,
          shadowOffset: this.settings.shadowOffset,
          enableBorder: this.settings.enableBorder,
          borderColor: this.settings.borderColor,
          borderWidth: this.settings.borderWidth,
          borderStyle: this.settings.borderStyle,
          onSubmit: (radius, unit, shadow, border) => this.applyRoundedFrameToMatches(view, all, radius, unit, shadow, border)
        });
        modal.open();
      }
    });
    this.addCommand({
      id: "rounded-frame-process-subfolder",
      name: "Rounded frame: process all images in current subfolder",
      callback: () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view || !view.file) {
          new import_obsidian3.Notice("Open a note inside the target folder to use this", 3e3);
          return;
        }
        this.processSubfolderImages(view);
      }
    });
    this.addCommand({
      id: "rounded-frame-process-vault",
      name: "Rounded frame: process all images in vault",
      callback: () => {
        this.processVaultImages();
      }
    });
    this.addCommand({
      id: "rounded-frame-undo-last",
      name: "Rounded frame: undo last action",
      callback: () => {
        if (!this.lastAction) {
          new import_obsidian3.Notice("No action to undo", 2e3);
          return;
        }
        this.undoLastAction();
      }
    });
    this.addCommand({
      id: "rounded-frame-confirm-last",
      name: "Rounded frame: confirm last action",
      callback: () => {
        if (!this.lastAction) {
          new import_obsidian3.Notice("No action to confirm", 2e3);
          return;
        }
        this.confirmLastAction();
      }
    });
    this.addCommand({
      id: "rounded-frame-emergency-recovery",
      name: "Rounded frame: emergency recovery (scan for backups)",
      callback: () => {
        this.emergencyRecoveryScan();
      }
    });
    this.addCommand({
      id: "rounded-frame-cleanup-backups",
      name: "Rounded frame: cleanup all backup files",
      callback: async () => {
        const confirmed = confirm("This will permanently delete ALL backup files in your vault. This action cannot be undone. Continue?");
        if (confirmed) {
          await this.forceCleanupAllBackups();
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onunload() {
    this.removeActionConfirmationPopup();
  }
  ensureUiStyles() {
    if (document.head.querySelector("#rounded-frame-ui"))
      return;
    const style = document.createElement("style");
    style.id = "rounded-frame-ui";
    style.textContent = `
			.rounded-frame-modal{padding:20px;min-width:360px;}
			.rounded-frame-effect-row{display:flex;gap:8px;margin-bottom:12px;}
			.rounded-frame-effect-row button{flex:1;}
			.rounded-frame-unit-row{display:flex;gap:8px;margin-bottom:12px;}
			.rounded-frame-unit-row button{flex:1;}
			.rounded-frame-section{margin-bottom:12px;}
			.rounded-frame-hidden{display:none;}
			.rounded-frame-slider{width:100%;}
			.rounded-frame-number{width:100%;}
			.rounded-frame-preview{display:flex;flex-direction:column;gap:16px;margin:16px 0;}
			.rounded-frame-thumbnail-container{text-align:center;}
			.rounded-frame-thumbnail-container h4{margin:0 0 8px 0;font-size:1em;}
			.rounded-frame-preview-thumbnail{display:block;margin:0 auto;border-radius:4px;}
			.rounded-frame-images-container{text-align:center;}
			.rounded-frame-images-container h4{margin:0 0 8px 0;font-size:1em;}
			.rounded-frame-preview-img{max-width:80px;max-height:80px;margin:2px;border:1px solid var(--background-modifier-border);object-fit:contain;border-radius:2px;}
			.rounded-frame-button-row{display:flex;justify-content:flex-end;gap:10px;margin-top:16px;}
			.rounded-frame-shadow-section, .rounded-frame-border-section{margin:12px 0;padding:12px;border:1px solid var(--background-modifier-border);border-radius:6px;}
			.rounded-frame-control-row{display:flex;align-items:center;gap:8px;margin-bottom:8px;}
			.rounded-frame-control-row span:first-child{min-width:80px;}
			.rounded-frame-control-row input[type="color"]{width:40px;height:30px;border:none;border-radius:4px;cursor:pointer;}
			.rounded-frame-control-row input[type="range"]{flex:1;}
			.rounded-frame-control-row select{width:100px;}
		`;
    document.head.appendChild(style);
  }
  async ensurePythonScript() {
    const pythonScript = path.join(this.app.vault.configDir, "plugins", this.manifest.id, "round_image.py");
    const pluginDir = path.dirname(pythonScript);
    if (!fs.existsSync(pluginDir)) {
      fs.mkdirSync(pluginDir, { recursive: true });
    }
    let shouldWrite = false;
    try {
      if (!fs.existsSync(pythonScript))
        shouldWrite = true;
      else {
        const stat = fs.statSync(pythonScript);
        if (stat.size < 5e3)
          shouldWrite = true;
      }
    } catch (e) {
      shouldWrite = true;
    }
    if (shouldWrite) {
      try {
        fs.writeFileSync(pythonScript, PY_ROUND_IMAGE, { encoding: "utf-8" });
        fs.chmodSync(pythonScript, 493);
      } catch (e) {
        console.warn("Failed to materialize embedded python script:", e);
      }
    }
  }
  refreshMatch(editor, match) {
    var _a;
    const line = editor.getLine(match.lineNumber);
    return line.slice(match.start, match.end) === match.raw ? match : (_a = this.findMatchInLine(line, match.lineNumber, { targetSrc: match.path })) != null ? _a : null;
  }
  findMatchInLine(line, lineNumber, opts = {}) {
    var _a;
    const candidates = this.collectMatches(line, lineNumber);
    if (opts.targetSrc) {
      const matched = candidates.find((c) => this.pathsMatch(opts.targetSrc, c.path));
      if (matched)
        return matched;
    }
    if (opts.cursorCh !== void 0) {
      const matched = candidates.find((c) => opts.cursorCh >= c.start && opts.cursorCh <= c.end);
      if (matched)
        return matched;
    }
    return (_a = candidates[0]) != null ? _a : null;
  }
  locateMatchBySrc(view, src) {
    if (!src)
      return null;
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const match = this.findMatchInLine(lines[lineNumber], lineNumber, { targetSrc: src });
      if (match)
        return match;
    }
    return null;
  }
  getAllMatches(view) {
    const out = [];
    const lines = view.editor.getValue().split("\n");
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const list = this.collectMatches(lines[lineNumber], lineNumber);
      for (const m of list)
        out.push(m);
    }
    return this.uniqueMatches(out);
  }
  getVisibleImages(view) {
    const root = view.containerEl;
    const imgs = Array.from(root.querySelectorAll("img"));
    const viewportH = window.innerHeight || document.documentElement.clientHeight;
    return imgs.filter((img) => {
      const r = img.getBoundingClientRect();
      const visible = r.bottom > 0 && r.top < viewportH && r.width > 0 && r.height > 0;
      const src = img.getAttribute("src") || img.getAttribute("data-src");
      return visible && !!src;
    });
  }
  uniqueMatches(matches) {
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const m of matches) {
      const key = `${m.lineNumber}:${m.start}:${m.end}`;
      if (!seen.has(key)) {
        seen.add(key);
        out.push(m);
      }
    }
    return out;
  }
  async applyRoundedFrameToMatches(view, matches, radius, unit, shadow, border) {
    const editor = view.editor;
    const refreshed = [];
    for (const m of matches) {
      const updated = this.refreshMatch(editor, m);
      if (updated)
        refreshed.push(updated);
    }
    refreshed.sort((a, b) => {
      if (a.lineNumber !== b.lineNumber) {
        return b.lineNumber - a.lineNumber;
      }
      return b.start - a.start;
    });
    await this.processImagesQueueFromMatches(view, refreshed, radius, unit, shadow, border);
    return;
  }
  async getImagesInCurrentSubfolder(view) {
    if (!view.file)
      return [];
    const currentFile = view.file;
    const currentFolder = currentFile.parent;
    if (!currentFolder)
      return [];
    const referencedImages = await this.getReferencedImagesInFolder(currentFolder);
    const physicalImages = this.getPhysicalImagesInFolder(currentFolder);
    const allImages = /* @__PURE__ */ new Map();
    for (const img of referencedImages) {
      allImages.set(img.path, img);
    }
    for (const img of physicalImages) {
      allImages.set(img.path, img);
    }
    return Array.from(allImages.values());
  }
  async getReferencedImagesInFolder(folder) {
    const referencedImages = [];
    const markdownFiles = this.getMarkdownFilesInFolder(folder);
    for (const mdFile of markdownFiles) {
      const content = await this.readFileContent(mdFile);
      if (!content)
        continue;
      const imageRefs = this.extractImageReferences(content);
      for (const imagePath of imageRefs) {
        const resolvedFile = this.resolveTFile(mdFile, imagePath);
        if (resolvedFile && !referencedImages.some((img) => img.path === resolvedFile.path)) {
          referencedImages.push(resolvedFile);
        }
      }
    }
    return referencedImages;
  }
  getPhysicalImagesInFolder(folder) {
    const folderPath = folder.path;
    const allFiles = this.app.vault.getFiles();
    const imagesInFolder = [];
    for (const file of allFiles) {
      if (file.path.startsWith(folderPath + "/")) {
        const extension = file.extension.toLowerCase();
        if (SUPPORTED_EXTENSIONS.includes(extension)) {
          imagesInFolder.push(file);
        }
      }
    }
    return imagesInFolder;
  }
  getMarkdownFilesInFolder(folder) {
    const markdownFiles = [];
    const folderPath = folder.path;
    const allFiles = this.app.vault.getFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(folderPath + "/") && file.extension.toLowerCase() === "md") {
        markdownFiles.push(file);
      }
    }
    return markdownFiles;
  }
  async readFileContent(file) {
    try {
      const content = await this.app.vault.read(file);
      return content;
    } catch (error) {
      console.error("Error reading file:", file.path, error);
      return null;
    }
  }
  extractImageReferences(content) {
    const imageRefs = [];
    const mdRegex = /!\[([^\]]*)\]\((?:<([^>]+)>|([^)\s]+))(?:\s+"([^"]*)")?\)/g;
    let mdMatch;
    while ((mdMatch = mdRegex.exec(content)) !== null) {
      const pathGroup = mdMatch[2] || mdMatch[3];
      if (pathGroup)
        imageRefs.push(pathGroup.trim());
    }
    const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
    let wikiMatch;
    while ((wikiMatch = wikiRegex.exec(content)) !== null) {
      imageRefs.push(wikiMatch[1].trim());
    }
    const htmlRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
    let htmlMatch;
    while ((htmlMatch = htmlRegex.exec(content)) !== null) {
      imageRefs.push(htmlMatch[1].trim());
    }
    return imageRefs;
  }
  async getImagesInVault() {
    const rootFolder = this.app.vault.getRoot();
    const referencedImages = await this.getReferencedImagesInFolder(rootFolder);
    const physicalImages = this.getPhysicalImagesInFolder(rootFolder);
    const allImages = /* @__PURE__ */ new Map();
    for (const img of referencedImages) {
      allImages.set(img.path, img);
    }
    for (const img of physicalImages) {
      allImages.set(img.path, img);
    }
    return Array.from(allImages.values());
  }
  getImageFilesInFolder(folder) {
    const images = [];
    for (const item of folder.children) {
      if (item instanceof import_obsidian3.TFile) {
        const extension = item.extension.toLowerCase();
        if (SUPPORTED_EXTENSIONS.includes(extension)) {
          images.push(item);
        }
      }
    }
    for (const item of folder.children) {
      if (item instanceof import_obsidian3.TFolder) {
        images.push(...this.getImageFilesInFolder(item));
      }
    }
    return images;
  }
  async processSubfolderImages(view) {
    try {
      const subfolderImages = await this.getImagesInCurrentSubfolder(view);
      if (subfolderImages.length === 0) {
        new import_obsidian3.Notice("No images found in current subfolder", 2e3);
        return;
      }
      const modal = new RoundedFrameModal(this.app, {
        initialRadius: this.settings.defaultPercent,
        initialUnit: this.settings.defaultUnit,
        defaultPercent: this.settings.defaultPercent,
        defaultPx: this.settings.defaultPx,
        imageSources: [],
        // No preview for bulk operations
        enableShadow: this.settings.enableShadow,
        shadowColor: this.settings.shadowColor,
        shadowBlur: this.settings.shadowBlur,
        shadowOffset: this.settings.shadowOffset,
        enableBorder: this.settings.enableBorder,
        borderColor: this.settings.borderColor,
        borderWidth: this.settings.borderWidth,
        onSubmit: async (radius, unit, shadow, border) => {
          await this.processBulkImages(view, subfolderImages, radius, unit, shadow, border);
          new import_obsidian3.Notice(`Processed ${subfolderImages.length} images in subfolder`, 3e3);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian3.Notice("Error processing subfolder images", 3e3);
      console.error(error);
    }
  }
  async processVaultImages() {
    try {
      const vaultImages = await this.getImagesInVault();
      if (vaultImages.length === 0) {
        new import_obsidian3.Notice("No images found in vault", 2e3);
        return;
      }
      const modal = new RoundedFrameModal(this.app, {
        initialRadius: this.settings.defaultPercent,
        initialUnit: this.settings.defaultUnit,
        defaultPercent: this.settings.defaultPercent,
        defaultPx: this.settings.defaultPx,
        imageSources: [],
        // No preview for bulk operations
        enableShadow: this.settings.enableShadow,
        shadowColor: this.settings.shadowColor,
        shadowBlur: this.settings.shadowBlur,
        shadowOffset: this.settings.shadowOffset,
        enableBorder: this.settings.enableBorder,
        borderColor: this.settings.borderColor,
        borderWidth: this.settings.borderWidth,
        onSubmit: async (radius, unit, shadow, border) => {
          await this.processBulkImages(null, vaultImages, radius, unit, shadow, border);
          new import_obsidian3.Notice(`Processed ${vaultImages.length} images in vault`, 3e3);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian3.Notice("Error processing vault images", 3e3);
      console.error(error);
    }
  }
  async processBulkImages(view, imageFiles, radius, unit, shadow, border) {
    await this.processImageFilesQueue(view, imageFiles, radius, unit, shadow, border);
    return;
  }
  getRelativePathForNote(viewOrFile, absolutePath, originalPath) {
    var _a, _b, _c, _d;
    const styleBase = originalPath != null ? originalPath : absolutePath;
    const currentFile = viewOrFile instanceof import_obsidian3.TFile ? viewOrFile : viewOrFile.file;
    let finalPath = absolutePath;
    if (styleBase.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(absolutePath);
      if (newFile) {
        const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
        const newFileDir = ((_b = newFile.parent) == null ? void 0 : _b.path) || "";
        if (newFileDir === currentDir) {
          finalPath = "./" + newFile.basename + "." + newFile.extension;
        } else if (currentDir && newFileDir.startsWith(currentDir + "/")) {
          const subPath = newFileDir.substring(currentDir.length + 1);
          finalPath = "./" + subPath + "/" + newFile.basename + "." + newFile.extension;
        } else {
          const currentParts = currentDir.split("/").filter((p) => p);
          const newParts = newFileDir.split("/").filter((p) => p);
          let commonLength = 0;
          while (commonLength < currentParts.length && commonLength < newParts.length && currentParts[commonLength] === newParts[commonLength]) {
            commonLength++;
          }
          const upLevels = currentParts.length - commonLength;
          const relativeParts = newParts.slice(commonLength);
          const fileName = newFile.basename + "." + newFile.extension;
          if (upLevels === 0 && relativeParts.length === 0) {
            finalPath = "./" + fileName;
          } else {
            finalPath = "../".repeat(upLevels) + relativeParts.join("/") + "/" + fileName;
          }
        }
      }
    } else if (!styleBase.startsWith("/") && !/^[A-Za-z]:/.test(styleBase) && !styleBase.startsWith("./") && currentFile) {
      const newFile = this.app.vault.getAbstractFileByPath(absolutePath);
      if (newFile) {
        const currentDir = ((_c = currentFile.parent) == null ? void 0 : _c.path) || "";
        const newFileDir = ((_d = newFile.parent) == null ? void 0 : _d.path) || "";
        if (newFileDir === currentDir) {
          finalPath = newFile.basename + "." + newFile.extension;
        }
      }
    }
    return finalPath;
  }
  buildReference(match, newPath) {
    if (match.kind === "markdown") {
      return `![${match.alt}](${newPath})`;
    } else if (match.kind === "wikilink") {
      return `![[${newPath}|${match.alt}]]`;
    } else {
      return `<img src="${newPath}" alt="${match.alt}">`;
    }
  }
  collectMatches(line, lineNumber) {
    var _a;
    const matches = [];
    const mdRegex = /!\[([^\]]*)\]\((?:<([^>]+)>|([^)\s]+))(?:\s+"([^"]*)")?\)/g;
    let md;
    while ((md = mdRegex.exec(line)) !== null) {
      const pathGroup = md[2] || md[3];
      const rawPath = (pathGroup || "").trim();
      const safePath = this.sanitizeImagePath(rawPath);
      if (!safePath)
        continue;
      matches.push({
        lineNumber,
        start: md.index,
        end: md.index + md[0].length,
        path: safePath,
        alt: (md[1] || "").trim(),
        raw: md[0],
        kind: "markdown"
      });
    }
    const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
    let wiki;
    while ((wiki = wikiRegex.exec(line)) !== null) {
      const path2 = wiki[1].trim();
      const alt = (wiki[2] || wiki[1] || "").trim();
      matches.push({
        lineNumber,
        start: wiki.index,
        end: wiki.index + wiki[0].length,
        path: path2,
        alt,
        raw: wiki[0],
        kind: "wikilink"
      });
    }
    const htmlRegex = /<img\s+[^>]*>/gi;
    let tag;
    while ((tag = htmlRegex.exec(line)) !== null) {
      const raw = tag[0];
      const path2 = this.getAttr(raw, "src");
      if (!path2)
        continue;
      const safePath = this.sanitizeImagePath(path2);
      if (!safePath)
        continue;
      matches.push({
        lineNumber,
        start: tag.index,
        end: tag.index + raw.length,
        path: safePath,
        alt: (_a = this.getAttr(raw, "alt")) != null ? _a : "",
        raw,
        kind: "html"
      });
    }
    return matches;
  }
  getAttr(tag, name) {
    var _a, _b;
    const attr = new RegExp(`${name}\\s*=\\s*("([^"]*)"|'([^']*)')`, "i").exec(tag);
    if (!attr)
      return null;
    return ((_b = (_a = attr[2]) != null ? _a : attr[3]) != null ? _b : "").trim();
  }
  sanitizeImagePath(raw) {
    if (!raw)
      return null;
    let p = raw.trim();
    try {
      const mdMatch = /!\[[^\]]*\]\(([^)]+)\)/.exec(p);
      if (mdMatch && mdMatch[1]) {
        p = mdMatch[1].trim();
      }
    } catch (e) {
    }
    try {
      const wikiMatch = /!\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/.exec(p);
      if (wikiMatch && wikiMatch[1]) {
        p = wikiMatch[1].trim();
      }
    } catch (e) {
    }
    if (p.includes("(") && p.includes(")")) {
      const lastOpen = p.lastIndexOf("(");
      const lastClose = p.indexOf(")", lastOpen + 1);
      if (lastOpen >= 0 && lastClose > lastOpen) {
        const inner = p.slice(lastOpen + 1, lastClose).trim();
        if (/(\.(png|jpg|jpeg|gif|webp|bmp|svg))(\?|#|$)/i.test(inner)) {
          p = inner;
        }
      }
    }
    p = p.replace(/\\+/g, "/");
    try {
      p = decodeURIComponent(p);
    } catch (e) {
    }
    p = p.replace(/^\.\//, "");
    const tokenMatchAll = p.match(/[^\s"'()]+\.(?:png|jpg|jpeg|gif|webp|bmp|svg)(?:[?#][^\s"'()]*)?/ig);
    if (tokenMatchAll && tokenMatchAll.length > 0) {
      p = tokenMatchAll[tokenMatchAll.length - 1];
    }
    const exts = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "svg"];
    let bestEnd = -1;
    for (const ext of exts) {
      const re = new RegExp(`\\.${ext}(?:[?#].*|$)`, "i");
      const m = re.exec(p);
      if (m && m.index + ("." + ext).length > bestEnd) {
        bestEnd = m.index + ("." + ext).length;
      }
    }
    if (bestEnd > 0)
      p = p.slice(0, bestEnd);
    if (/\n|\r/.test(p))
      return null;
    return p || null;
  }
  resolveTFile(viewOrFile, link) {
    var _a, _b, _c;
    if (/^https?:/i.test(link))
      return null;
    const sanitized = this.sanitizeImagePath(link);
    const candidate = sanitized != null ? sanitized : link;
    let decodedLink = candidate;
    decodedLink = decodedLink.replace(/^\.\//, "");
    const baseFile = viewOrFile instanceof import_obsidian3.TFile ? viewOrFile : viewOrFile.file;
    const base = (_a = baseFile == null ? void 0 : baseFile.path) != null ? _a : "";
    let file = this.app.metadataCache.getFirstLinkpathDest(decodedLink, base);
    if (file)
      return file;
    file = this.app.vault.getAbstractFileByPath(decodedLink);
    if (file)
      return file;
    if (baseFile) {
      const parentPath = (_c = (_b = baseFile.parent) == null ? void 0 : _b.path) != null ? _c : "";
      const fullPath = parentPath ? `${parentPath}/${decodedLink}` : decodedLink;
      file = this.app.vault.getAbstractFileByPath(fullPath);
      if (file)
        return file;
    }
    const filename = path.basename(decodedLink);
    const allFiles = this.app.vault.getFiles();
    const exactMatch = allFiles.find((f) => f.name === filename);
    if (exactMatch)
      return exactMatch;
    const partialMatch = allFiles.find((f) => f.name.toLowerCase() === filename.toLowerCase() || f.path.endsWith(filename));
    if (partialMatch)
      return partialMatch;
    return null;
  }
  async ensureBackupFolder() {
    try {
      const backupFolder = this.app.vault.getAbstractFileByPath(this.BACKUP_FOLDER);
      if (!backupFolder) {
        await this.app.vault.createFolder(this.BACKUP_FOLDER);
      }
    } catch (error) {
      if ((error == null ? void 0 : error.message) && error.message.includes("Folder already exists")) {
        return;
      }
      console.warn("Failed to create backup folder:", error);
    }
  }
  async createBackup(originalPath) {
    await this.ensureBackupFolder();
    const timestamp = Date.now();
    const filename = path.basename(originalPath);
    const backupPath = `${this.BACKUP_FOLDER}/${timestamp}-${filename}`;
    try {
      const originalFile = this.app.vault.getAbstractFileByPath(originalPath);
      if (originalFile && originalFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.readBinary(originalFile);
        await this.app.vault.createBinary(backupPath, content);
        return backupPath;
      }
    } catch (error) {
      console.error(`Failed to create backup for ${originalPath}:`, error);
    }
    return "";
  }
  async createLocalBackup(originalPath) {
    const dirname2 = path.dirname(originalPath);
    const filename = path.basename(originalPath);
    const ext = path.extname(filename);
    const base = path.basename(filename, ext);
    const timestamp = Date.now();
    const backupPath = dirname2 ? `${dirname2}/${base}.backup-${timestamp}${ext}` : `${base}.backup-${timestamp}${ext}`;
    try {
      const originalFile = this.app.vault.getAbstractFileByPath(originalPath);
      if (originalFile && originalFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.readBinary(originalFile);
        await this.app.vault.createBinary(backupPath, content);
        console.log(`Created local backup: ${backupPath}`);
        return backupPath;
      }
    } catch (error) {
      console.error(`Failed to create local backup for ${originalPath}:`, error);
    }
    return "";
  }
  async restoreFromBackup(backupPath, targetPath) {
    try {
      const backupFile = this.app.vault.getAbstractFileByPath(backupPath);
      if (backupFile && backupFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.readBinary(backupFile);
        const existingTarget = this.app.vault.getAbstractFileByPath(targetPath);
        if (existingTarget instanceof import_obsidian3.TFile) {
          await this.app.vault.modifyBinary(existingTarget, content);
        } else if (!existingTarget) {
          await this.app.vault.createBinary(targetPath, content);
        }
        return true;
      }
    } catch (error) {
      console.error(`Failed to restore from backup ${backupPath}:`, error);
    }
    return false;
  }
  async clearLastActionBackups() {
    if (!this.lastAction)
      return;
    for (const backupPath of this.lastAction.backupPaths) {
      try {
        const backupFile = this.app.vault.getAbstractFileByPath(backupPath);
        if (backupFile && backupFile instanceof import_obsidian3.TFile) {
          await this.app.vault.delete(backupFile);
        }
      } catch (error) {
        console.warn(`Failed to delete backup ${backupPath}:`, error);
      }
    }
    for (const localBackupPath of this.lastAction.localBackupPaths) {
      try {
        const localBackupFile = this.app.vault.getAbstractFileByPath(localBackupPath);
        if (localBackupFile && localBackupFile instanceof import_obsidian3.TFile) {
          await this.app.vault.delete(localBackupFile);
          console.log(`Cleaned up local backup: ${localBackupPath}`);
        }
      } catch (error) {
        console.warn(`Failed to delete local backup ${localBackupPath}:`, error);
      }
    }
    this.lastAction = null;
  }
  async undoLastAction() {
    if (!this.lastAction) {
      new import_obsidian3.Notice("No action to undo", 2e3);
      return;
    }
    let successCount = 0;
    let failCount = 0;
    for (let i = 0; i < this.lastAction.originalPaths.length; i++) {
      const originalPath = this.lastAction.originalPaths[i];
      let restored = false;
      if (i < this.lastAction.backupPaths.length) {
        const backupPath = this.lastAction.backupPaths[i];
        if (await this.restoreFromBackup(backupPath, originalPath)) {
          restored = true;
        }
      }
      if (!restored && i < this.lastAction.localBackupPaths.length) {
        const localBackupPath = this.lastAction.localBackupPaths[i];
        if (await this.restoreFromBackup(localBackupPath, originalPath)) {
          restored = true;
          console.log(`Restored from local backup: ${localBackupPath}`);
        }
      }
      if (restored) {
        successCount++;
      } else {
        failCount++;
      }
    }
    for (const newPath of this.lastAction.newPaths) {
      try {
        const processedFile = this.app.vault.getAbstractFileByPath(newPath);
        if (processedFile && processedFile instanceof import_obsidian3.TFile) {
          await this.app.vault.delete(processedFile);
        }
      } catch (error) {
        console.warn(`Failed to delete processed image ${newPath}:`, error);
        failCount++;
      }
    }
    await this.clearLastActionBackups();
    if (failCount === 0) {
      new import_obsidian3.Notice(`Successfully undone last action (${successCount} images restored)`, 3e3);
    } else {
      new import_obsidian3.Notice(`Partially undone last action (${successCount} restored, ${failCount} failed)`, 3e3);
    }
  }
  async confirmLastAction() {
    if (!this.lastAction) {
      new import_obsidian3.Notice("No action to confirm", 2e3);
      return;
    }
    await this.clearLastActionBackups();
    new import_obsidian3.Notice("Last action confirmed - backups cleaned up", 2e3);
  }
  async emergencyRecoveryScan() {
    const allFiles = this.app.vault.getFiles();
    const backupFiles = [];
    const localBackupFiles = [];
    for (const file of allFiles) {
      if (file.path.startsWith(this.BACKUP_FOLDER + "/")) {
        backupFiles.push(file);
      } else if (file.name.includes(".backup-")) {
        localBackupFiles.push(file);
      }
    }
    const totalBackups = backupFiles.length + localBackupFiles.length;
    if (totalBackups === 0) {
      new import_obsidian3.Notice("No backup files found in vault", 3e3);
      return;
    }
    const message = `Found ${totalBackups} backup files:
\u2022 ${backupFiles.length} in hidden backup folder
\u2022 ${localBackupFiles.length} local backups

Check the console for detailed file list.`;
    new import_obsidian3.Notice(message, 5e3);
    console.log("=== EMERGENCY RECOVERY SCAN ===");
    console.log("Hidden backup folder files:");
    backupFiles.forEach((file) => console.log(`  ${file.path} (${file.stat.size} bytes)`));
    console.log("Local backup files:");
    localBackupFiles.forEach((file) => console.log(`  ${file.path} (${file.stat.size} bytes)`));
    console.log("=== END RECOVERY SCAN ===");
    console.log("To restore files manually:");
    console.log("1. Identify the backup file you want to restore");
    console.log("2. Copy it to replace the original file path");
    console.log("3. Delete the backup file when done");
  }
  async forceCleanupAllBackups() {
    const allFiles = this.app.vault.getFiles();
    let deletedCount = 0;
    for (const file of allFiles) {
      if (file.path.startsWith(this.BACKUP_FOLDER + "/") || file.name.includes(".backup-")) {
        try {
          await this.app.vault.delete(file);
          deletedCount++;
        } catch (error) {
          console.warn(`Failed to delete backup file: ${file.path}`, error);
        }
      }
    }
    this.lastAction = null;
    if (deletedCount > 0) {
      new import_obsidian3.Notice(`Cleaned up ${deletedCount} backup files`, 3e3);
    } else {
      new import_obsidian3.Notice("No backup files found to clean up", 2e3);
    }
  }
  showActionConfirmationPopup() {
    if (!this.lastAction)
      return;
    this.removeActionConfirmationPopup();
    const popup = document.createElement("div");
    popup.id = "rounded-frame-confirmation-popup";
    popup.style.cssText = `
			position: fixed;
			top: 20px;
			right: 20px;
			background: var(--background-primary, #ffffff);
			border: 2px solid var(--interactive-accent, #4a90e2);
			border-radius: 8px;
			padding: 16px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
			z-index: 10000;
			max-width: 350px;
			font-family: var(--font-interface, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
			color: var(--text-normal, #333333);
		`;
    const title = document.createElement("div");
    title.textContent = "\u2705 Image Processing Complete";
    title.style.cssText = `
			font-weight: bold;
			font-size: 14px;
			margin-bottom: 8px;
			color: var(--text-accent, #4a90e2);
		`;
    const message = document.createElement("div");
    const imageCount = this.lastAction.newPaths.length;
    message.textContent = `Successfully processed ${imageCount} image${imageCount !== 1 ? "s" : ""}. Backups created for safety.`;
    message.style.cssText = `
			font-size: 13px;
			margin-bottom: 12px;
			line-height: 1.4;
		`;
    const question = document.createElement("div");
    question.textContent = "Keep the changes or revert?";
    question.style.cssText = `
			font-size: 12px;
			margin-bottom: 12px;
			font-style: italic;
			color: var(--text-muted, #888888);
		`;
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 8px;
			justify-content: flex-end;
		`;
    const confirmButton = document.createElement("button");
    confirmButton.textContent = "\u2705 Confirm";
    confirmButton.style.cssText = `
			padding: 6px 12px;
			background: var(--interactive-accent, #4a90e2);
			color: var(--text-on-accent, #ffffff);
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			font-weight: 500;
			transition: background-color 0.2s;
		`;
    confirmButton.onmouseover = () => {
      confirmButton.style.background = "var(--interactive-accent-hover, #357abd)";
    };
    confirmButton.onmouseout = () => {
      confirmButton.style.background = "var(--interactive-accent, #4a90e2)";
    };
    confirmButton.onclick = async () => {
      await this.confirmLastAction();
      this.removeActionConfirmationPopup();
    };
    const undoButton = document.createElement("button");
    undoButton.textContent = "\u21B6 Undo";
    undoButton.style.cssText = `
			padding: 6px 12px;
			background: var(--background-modifier-error, #ff6b6b);
			color: var(--text-on-accent, #ffffff);
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			font-weight: 500;
			transition: background-color 0.2s;
		`;
    undoButton.onmouseover = () => {
      undoButton.style.background = "var(--background-modifier-error-hover, #ff5252)";
    };
    undoButton.onmouseout = () => {
      undoButton.style.background = "var(--background-modifier-error, #ff6b6b)";
    };
    undoButton.onclick = async () => {
      await this.undoLastAction();
      this.removeActionConfirmationPopup();
    };
    const dismissButton = document.createElement("button");
    dismissButton.textContent = "\u2715";
    dismissButton.style.cssText = `
			position: absolute;
			top: 8px;
			right: 8px;
			background: none;
			border: none;
			cursor: pointer;
			font-size: 16px;
			color: var(--text-muted, #888888);
			padding: 0;
			width: 20px;
			height: 20px;
			display: flex;
			align-items: center;
			justify-content: center;
		`;
    dismissButton.onclick = () => {
      this.removeActionConfirmationPopup();
    };
    setTimeout(() => {
      this.removeActionConfirmationPopup();
    }, 3e4);
    buttonContainer.appendChild(undoButton);
    buttonContainer.appendChild(confirmButton);
    popup.appendChild(dismissButton);
    popup.appendChild(title);
    popup.appendChild(message);
    popup.appendChild(question);
    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
    popup.style.opacity = "0";
    popup.style.transform = "translateY(-10px)";
    setTimeout(() => {
      popup.style.transition = "all 0.3s ease";
      popup.style.opacity = "1";
      popup.style.transform = "translateY(0)";
    }, 10);
  }
  removeActionConfirmationPopup() {
    const existingPopup = document.getElementById("rounded-frame-confirmation-popup");
    if (existingPopup) {
      existingPopup.style.transition = "all 0.3s ease";
      existingPopup.style.opacity = "0";
      existingPopup.style.transform = "translateY(-10px)";
      setTimeout(() => {
        if (existingPopup.parentNode) {
          existingPopup.parentNode.removeChild(existingPopup);
        }
      }, 300);
    }
  }
  async roundImageFile(file, radius, unit, shadow, border) {
    var _a, _b;
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const useSuffix = this.settings.dualImageSystem;
    const newPath = useSuffix ? folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png` : file.path;
    const tempPath = `${newPath}.processing-${Date.now()}`;
    try {
      await this.roundImageWithPython(file.path, tempPath, radius, unit, shadow, border);
      const tempFile = this.app.vault.getAbstractFileByPath(tempPath);
      if (!tempFile || !(tempFile instanceof import_obsidian3.TFile)) {
        throw new Error(`Failed to create temporary processed file: ${tempPath}`);
      }
      if (tempFile.stat.size === 0) {
        throw new Error(`Processed file is empty: ${tempPath}`);
      }
      const arrayBuffer = await this.app.vault.readBinary(tempFile);
      await this.writeRoundedVersion(newPath, new Blob([arrayBuffer], { type: "image/png" }));
      try {
        await this.app.vault.delete(tempFile);
      } catch (e) {
      }
      return { blob: new Blob([arrayBuffer], { type: "image/png" }), newPath };
    } catch (pythonError) {
      try {
        const tempFile = this.app.vault.getAbstractFileByPath(tempPath);
        if (tempFile && tempFile instanceof import_obsidian3.TFile) {
          await this.app.vault.delete(tempFile);
        }
      } catch (cleanupError) {
        console.warn(`Failed to cleanup temporary file ${tempPath}:`, cleanupError);
      }
      try {
        const result = await this.roundImageWithCanvas(file, radius, unit);
        await this.writeRoundedVersion(newPath, result.blob);
        return { blob: result.blob, newPath };
      } catch (canvasError) {
        throw new Error(`Image processing failed for ${file.path}. Python error: ${pythonError.message}, Canvas error: ${canvasError.message}`);
      }
    }
  }
  async roundImageWithPython(inputPath, outputPath, radius, unit, shadow, border) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const pythonScript = path.join(this.app.vault.configDir, "plugins", this.manifest.id, "round_image.py");
    const inputFile = this.app.vault.getAbstractFileByPath(inputPath);
    if (!inputFile)
      throw new Error(`File not found: ${inputPath}`);
    if (!fs.existsSync(pythonScript)) {
      throw new Error("Python script not found. Please ensure round_image.py is in the plugin directory.");
    }
    const adapter = this.app.vault.adapter;
    const vaultBase = adapter.basePath || "";
    const fullInputPath = vaultBase ? path.join(vaultBase, inputPath) : inputPath;
    const fullOutputPath = vaultBase ? path.join(vaultBase, outputPath) : outputPath;
    const outputDir = path.dirname(fullOutputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    let pythonCmd = "python3";
    try {
      await execAsync(`which python3`);
    } catch (e) {
      pythonCmd = "python";
    }
    let command = `${pythonCmd} "${pythonScript}" "${fullInputPath}" "${fullOutputPath}" ${radius} ${unit}`;
    if (shadow || border) {
      const shadowEnabled = (_a = shadow == null ? void 0 : shadow.enabled) != null ? _a : false;
      const shadowColor = (_b = shadow == null ? void 0 : shadow.color) != null ? _b : "#000000";
      const shadowBlur = (_c = shadow == null ? void 0 : shadow.blur) != null ? _c : 10;
      const shadowOffset = (_d = shadow == null ? void 0 : shadow.offset) != null ? _d : 5;
      const borderEnabled = (_e = border == null ? void 0 : border.enabled) != null ? _e : false;
      const borderColor = (_f = border == null ? void 0 : border.color) != null ? _f : "#cccccc";
      const borderWidth = (_g = border == null ? void 0 : border.width) != null ? _g : 2;
      const borderStyle = (_h = border == null ? void 0 : border.style) != null ? _h : "solid";
      command += ` ${shadowEnabled} "${shadowColor}" ${shadowBlur} ${shadowOffset} ${borderEnabled} "${borderColor}" ${borderWidth} ${borderStyle}`;
    }
    const { stdout, stderr } = await execAsync(command, { timeout: 3e4 });
    if (stderr && !stdout.includes("SUCCESS")) {
      throw new Error(`Python error: ${stderr}`);
    }
  }
  async roundImageWithCanvas(file, radius, unit) {
    var _a, _b;
    const arrayBuffer = await this.app.vault.readBinary(file);
    const blob = new Blob([arrayBuffer]);
    const img = await this.loadImageFromBlob(blob);
    const w = img.naturalWidth;
    const h = img.naturalHeight;
    const baseDimension = Math.min(w, h);
    const maxRadius = baseDimension / 2;
    let radiusPx;
    if (unit === "percent") {
      radiusPx = radius / 100 * baseDimension;
    } else {
      radiusPx = radius;
    }
    radiusPx = Math.min(radiusPx, maxRadius);
    radiusPx = Math.max(0, radiusPx);
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, w, h);
    ctx.globalCompositeOperation = "destination-in";
    ctx.beginPath();
    this.drawRoundedRect(ctx, 0, 0, w, h, radiusPx);
    ctx.closePath();
    ctx.fill();
    const roundedBlob = await new Promise((resolve, reject) => {
      canvas.toBlob((b) => b ? resolve(b) : reject(new Error("toBlob failed")), "image/png");
    });
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const base = file.basename;
    const suffix = unit === "percent" ? `${radius}p` : `${radius}px`;
    const newPath = folder ? `${folder}/${base}-rounded-${suffix}.png` : `${base}-rounded-${suffix}.png`;
    return { blob: roundedBlob, newPath };
  }
  drawRoundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr);
    ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h);
    ctx.quadraticCurveTo(x, y, x + h, y + h - rr);
    ctx.lineTo(x, y + rr);
    ctx.quadraticCurveTo(x, y, x + rr, y);
  }
  async loadImageFromBlob(blob) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(blob);
    });
  }
  async writeRoundedVersion(path2, blob) {
    const arrayBuffer = await blob.arrayBuffer();
    const existing = this.app.vault.getAbstractFileByPath(path2);
    if (existing) {
      await this.app.vault.modifyBinary(existing, arrayBuffer);
    } else {
      await this.app.vault.createBinary(path2, arrayBuffer);
    }
  }
  updateReference(editor, view, match, newPath) {
    const finalPath = this.getRelativePathForNote(view, newPath, match.path);
    const originalPath = match.path;
    let processedPath = finalPath;
    if (originalPath.includes("%20") || originalPath.includes(" ")) {
      processedPath = finalPath.replace(/ /g, "%20");
    }
    const replacement = this.buildReference(match, processedPath);
    editor.replaceRange(replacement, { line: match.lineNumber, ch: match.start }, { line: match.lineNumber, ch: match.end });
  }
  resolvePreviewSrc(view, match) {
    var _a;
    const path2 = match.path;
    if (/^https?:/i.test(path2))
      return path2;
    const file = view.file;
    const resolved = this.app.metadataCache.getFirstLinkpathDest(path2, (_a = file == null ? void 0 : file.path) != null ? _a : "");
    if (resolved)
      return this.app.vault.getResourcePath(resolved);
    return path2;
  }
  storeLast(radius, unit) {
    if (!this.settings.rememberLast)
      return;
    this.settings.lastUnit = unit;
    if (unit === "percent")
      this.settings.lastPercent = radius;
    else
      this.settings.lastPx = radius;
    void this.saveSettings();
  }
  getInitialRadius() {
    const useLast = this.settings.rememberLast;
    const unit = useLast ? this.settings.lastUnit : this.settings.defaultUnit;
    const radius = unit === "percent" ? useLast ? this.settings.lastPercent : this.settings.defaultPercent : useLast ? this.settings.lastPx : this.settings.defaultPx;
    return { unit, radius };
  }
  pathsMatch(a, b) {
    const decode = (value) => {
      try {
        return decodeURIComponent(value);
      } catch (e) {
        return value;
      }
    };
    const norm = (value) => {
      const decoded = decode(value);
      return decoded.split("?")[0].replace(/\\+/g, "/").toLowerCase().replace(/^\.\//, "");
    };
    const left = norm(a);
    const right = norm(b);
    return left === right || left.endsWith(`/${right}`) || right.endsWith(`/${left}`);
  }
  escapeAttr(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  async sleep(ms) {
    await new Promise((resolve) => setTimeout(resolve, ms));
  }
  async appendDebugLog(event, details) {
    if (!this.settings.debugMode)
      return;
    try {
      const timestamp = new Date().toISOString();
      let entry = `[${timestamp}] ${event}`;
      if (details) {
        entry += `
${JSON.stringify(details, null, 2)}`;
      }
      console.log(`[Image Rounded Frame Debug] ${entry}`);
      entry += `
`;
      const existing = this.app.vault.getAbstractFileByPath(this.DEBUG_LOG_PATH);
      if (existing) {
        const prev = await this.app.vault.read(existing);
        await this.app.vault.modify(existing, prev + entry);
      } else {
        await this.app.vault.create(this.DEBUG_LOG_PATH, entry);
      }
    } catch (e) {
      console.warn("Failed to write debug log:", e);
    }
  }
  startProgressPopup(total) {
    this.removeProgressPopup();
    const popup = document.createElement("div");
    popup.id = "rounded-frame-progress-popup";
    popup.style.cssText = `
			position: fixed;
			top: 20px;
			right: 20px;
			background: var(--background-secondary, #f5f5f5);
			border: 1px solid var(--background-modifier-border, #ccc);
			border-radius: 8px;
			padding: 12px 14px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			z-index: 10000;
			min-width: 260px;
			font-size: 12px;
		`;
    popup.innerHTML = `
			<div style="font-weight:600;margin-bottom:6px;">Processing images\u2026</div>
			<div id="rf-progress-text">0/${total} done (0 success, 0 failed)</div>
			<div id="rf-progress-current" style="margin-top:6px;color:var(--text-muted,#888);"></div>
		`;
    document.body.appendChild(popup);
    this.progressPopup = popup;
  }
  updateProgressPopup(done, success, failed, total, current) {
    const popup = this.progressPopup;
    if (!popup)
      return;
    const textEl = popup.querySelector("#rf-progress-text");
    if (textEl)
      textEl.textContent = `${done}/${total} done (${success} success, ${failed} failed)`;
    const curEl = popup.querySelector("#rf-progress-current");
    if (curEl)
      curEl.textContent = current ? `Current: ${current}` : "";
  }
  finishProgressPopup(summary) {
    const popup = this.progressPopup;
    if (!popup)
      return;
    const textEl = popup.querySelector("#rf-progress-text");
    if (textEl)
      textEl.textContent = summary;
    setTimeout(() => this.removeProgressPopup(), 1500);
  }
  removeProgressPopup() {
    if (this.progressPopup && this.progressPopup.parentElement) {
      this.progressPopup.parentElement.removeChild(this.progressPopup);
    }
    this.progressPopup = null;
  }
  /**
   * Unified core logic for processing a single image file.
   * Handles backups, rounding, and overwrite/dual-image logic.
   */
  async processSingleImage(file, radius, unit, shadow, border) {
    try {
      try {
        await this.app.vault.readBinary(file);
      } catch (readErr) {
        await this.appendDebugLog("READ_FAILED", { path: file.path, error: String(readErr) });
        return { success: false };
      }
      const hiddenBackup = await this.createBackup(file.path);
      const localBackup = await this.createLocalBackup(file.path);
      if (!hiddenBackup && !localBackup) {
        await this.appendDebugLog("BACKUP_FAILED", { path: file.path });
        return { success: false };
      }
      await this.appendDebugLog("BACKUP_CREATED", { path: file.path, hidden: hiddenBackup, local: localBackup });
      try {
        const { newPath } = await this.roundImageFile(file, radius, unit, shadow, border);
        const finalFile = this.app.vault.getAbstractFileByPath(newPath);
        if (!finalFile || !(finalFile instanceof import_obsidian3.TFile) || finalFile.stat.size === 0) {
          if (hiddenBackup) {
            const f = this.app.vault.getAbstractFileByPath(hiddenBackup);
            if (f)
              await this.app.vault.delete(f);
          }
          if (localBackup) {
            const f2 = this.app.vault.getAbstractFileByPath(localBackup);
            if (f2)
              await this.app.vault.delete(f2);
          }
          await this.appendDebugLog("PROCESSING_OUTPUT_INVALID", { source: file.path, output: newPath });
          return { success: false };
        }
        await this.appendDebugLog("PROCESSING_SUCCESS", { source: file.path, output: newPath });
        if (!this.settings.dualImageSystem) {
          this.refreshOpenNotes(file.path);
        }
        return {
          success: true,
          newPath,
          backup: hiddenBackup || localBackup || void 0
        };
      } catch (err) {
        try {
          if (hiddenBackup) {
            const bf = this.app.vault.getAbstractFileByPath(hiddenBackup);
            if (bf)
              await this.app.vault.delete(bf);
          }
        } catch (e) {
        }
        try {
          if (localBackup) {
            const lbf = this.app.vault.getAbstractFileByPath(localBackup);
            if (lbf)
              await this.app.vault.delete(lbf);
          }
        } catch (e) {
        }
        await this.appendDebugLog("PROCESSING_EXCEPTION", { path: file.path, error: String((err == null ? void 0 : err.stack) || err) });
        return { success: false };
      }
    } catch (outer) {
      await this.appendDebugLog("UNEXPECTED_FAILURE", { path: file.path, error: String(outer) });
      return { success: false };
    }
  }
  async processImagesQueueFromMatches(view, refreshed, radius, unit, shadow, border) {
    var _a, _b, _c, _d;
    this.style.updateStyles(radius, unit, shadow, border);
    const total = refreshed.length;
    let done = 0, success = 0, failed = 0;
    const originalPaths = [];
    const backupPaths = [];
    const localBackupPaths = [];
    const newPaths = [];
    const successMatches = [];
    this.startProgressPopup(total);
    const queue = new PromiseQueue(3);
    const tasks = [];
    for (const m of refreshed) {
      tasks.push(queue.add(async () => {
        this.updateProgressPopup(done, success, failed, total, m.path);
        try {
          const file = this.resolveTFile(view, m.path);
          if (!file) {
            await this.appendDebugLog("FILE_NOT_FOUND", { path: m.path, mode: "note", resolution_attempts: ["metadataCache", "direct", "relative", "vault_search"] });
            failed++;
            done++;
            this.updateProgressPopup(done, success, failed, total);
            return;
          }
          const result = await this.processSingleImage(file, radius, unit, shadow, border);
          if (result.success && result.newPath) {
            successMatches.push({ match: m, newPath: result.newPath });
            originalPaths.push(file.path);
            newPaths.push(result.newPath);
            const backupFile = this.app.vault.getAbstractFileByPath(this.BACKUP_FOLDER);
            if (backupFile) {
              if (result.backup)
                backupPaths.push(result.backup);
            }
            success++;
          } else {
            failed++;
          }
          done++;
          this.updateProgressPopup(done, success, failed, total);
        } catch (outer) {
          await this.appendDebugLog("UNEXPECTED_FAILURE_NOTE", { path: m.path, error: String(outer) });
          failed++;
          done++;
          this.updateProgressPopup(done, success, failed, total);
        }
      }));
    }
    await Promise.all(tasks);
    const uniqueSuccessFiles = /* @__PURE__ */ new Map();
    for (const item of successMatches) {
      const file = this.resolveTFile(view, item.match.path);
      if (file) {
        uniqueSuccessFiles.set(file.path, { file, newPath: item.newPath });
      }
    }
    for (const [path2, info] of uniqueSuccessFiles) {
      if (this.settings.dualImageSystem) {
        await this.updateAllVaultReferences(info.file, info.newPath, view.file || void 0);
      }
    }
    successMatches.sort((a, b) => {
      if (a.match.lineNumber !== b.match.lineNumber) {
        return b.match.lineNumber - a.match.lineNumber;
      }
      return b.match.start - a.match.start;
    });
    if (this.settings.dualImageSystem && successMatches.length > 0) {
      const changes = successMatches.map((item) => {
        const match = item.match;
        const finalPath = this.getRelativePathForNote(view, item.newPath, match.path);
        let processedPath = finalPath;
        if (match.path.includes("%20") || match.path.includes(" ")) {
          processedPath = finalPath.replace(/ /g, "%20");
        }
        const replacement = this.buildReference(match, processedPath);
        const currentLine = view.editor.getLine(match.lineNumber);
        if (!currentLine.includes(match.path)) {
          const reFind = this.findMatchInLine(currentLine, match.lineNumber, { targetSrc: match.path });
          if (reFind) {
            return {
              from: { line: match.lineNumber, ch: reFind.start },
              to: { line: match.lineNumber, ch: reFind.end },
              text: replacement
            };
          }
          console.warn(`[Image Rounded Frame] Skipping update for ${match.path} - content changed on line ${match.lineNumber}`);
          return null;
        }
        return {
          from: { line: match.lineNumber, ch: match.start },
          to: { line: match.lineNumber, ch: match.end },
          text: replacement
        };
      }).filter((c) => c !== null);
      if (changes && changes.length > 0) {
        view.editor.transaction({
          changes
        });
      }
    } else if (!this.settings.dualImageSystem && successMatches.length > 0) {
      for (const item of successMatches) {
        const file = this.resolveTFile(view, item.match.path);
        if (file)
          this.refreshOpenNotes(file.path);
      }
    }
    if (newPaths.length > 0) {
      this.lastAction = { originalPaths, backupPaths, localBackupPaths, newPaths, notePath: (_b = (_a = view.file) == null ? void 0 : _a.path) != null ? _b : "", timestamp: Date.now() };
      this.showActionConfirmationPopup();
    }
    this.finishProgressPopup(`Completed ${done}/${total}: ${success} success, ${failed} failed`);
    if (failed > 0) {
      await this.appendDebugLog("SUMMARY_NOTE", { total, success, failed, note: (_d = (_c = view.file) == null ? void 0 : _c.path) != null ? _d : "" });
    }
    this.storeLast(radius, unit);
  }
  async processImageFilesQueue(view, imageFiles, radius, unit, shadow, border) {
    var _a, _b;
    this.style.updateStyles(radius, unit, shadow, border);
    const total = imageFiles.length;
    let done = 0, success = 0, failed = 0;
    const originalPaths = [];
    const backupPaths = [];
    const localBackupPaths = [];
    const newPaths = [];
    this.startProgressPopup(total);
    const queue = new PromiseQueue(3);
    const tasks = [];
    for (const imageFile of imageFiles) {
      tasks.push(queue.add(async () => {
        this.updateProgressPopup(done, success, failed, total, imageFile.path);
        try {
          const result = await this.processSingleImage(imageFile, radius, unit, shadow, border);
          if (result.success && result.newPath) {
            originalPaths.push(imageFile.path);
            if (result.backup)
              backupPaths.push(result.backup);
            newPaths.push(result.newPath);
            success++;
          } else {
            failed++;
          }
          done++;
          this.updateProgressPopup(done, success, failed, total);
        } catch (outer) {
          await this.appendDebugLog("UNEXPECTED_FAILURE_BULK", { path: imageFile.path, error: String(outer) });
          failed++;
          done++;
          this.updateProgressPopup(done, success, failed, total);
        }
      }));
    }
    await Promise.all(tasks);
    if (newPaths.length > 0) {
      if (this.settings.dualImageSystem) {
        for (let i = 0; i < originalPaths.length; i++) {
          const originalFile = this.app.vault.getAbstractFileByPath(originalPaths[i]);
          if (originalFile) {
            await this.updateAllVaultReferences(originalFile, newPaths[i], (view == null ? void 0 : view.file) || void 0);
          }
        }
      } else {
        for (const originalPath of originalPaths) {
          this.refreshOpenNotes(originalPath);
        }
      }
      this.lastAction = { originalPaths, backupPaths, localBackupPaths, newPaths, notePath: (_b = (_a = view == null ? void 0 : view.file) == null ? void 0 : _a.path) != null ? _b : "", timestamp: Date.now() };
      this.showActionConfirmationPopup();
    }
    this.finishProgressPopup(`Completed ${done}/${total}: ${success} success, ${failed} failed`);
    if (failed > 0) {
      await this.appendDebugLog("SUMMARY_BULK", { total, success, failed });
    }
  }
  /**
   * Updates all references to an image file across the entire vault.
   */
  async updateAllVaultReferences(targetFile, newPath, skipFile) {
    const allFiles = this.app.vault.getMarkdownFiles();
    let updatedCount = 0;
    for (const file of allFiles) {
      if (skipFile && file.path === skipFile.path)
        continue;
      let changed = false;
      await this.app.vault.process(file, (content) => {
        let newContent = content;
        const mdRegex = /!\[([^\]]*)\]\((?:<([^>]+)>|([^)\s]+))(?:\s+"([^"]*)")?\)/g;
        newContent = newContent.replace(mdRegex, (match, alt, pathBrackets, pathNormal, title) => {
          const linkPath = pathBrackets || pathNormal;
          const resolved = this.app.metadataCache.getFirstLinkpathDest(linkPath, file.path);
          if (resolved && resolved.path === targetFile.path) {
            changed = true;
            const finalPath = this.getRelativePathForNote(file, newPath, linkPath);
            const processedPath = linkPath.includes("%20") || linkPath.includes(" ") ? finalPath.replace(/ /g, "%20") : finalPath;
            const titleStr = title ? ` "${title}"` : "";
            return `![${alt}](${processedPath}${titleStr})`;
          }
          return match;
        });
        const wikiRegex = /!\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g;
        newContent = newContent.replace(wikiRegex, (match, linkPath, alt) => {
          const resolved = this.app.metadataCache.getFirstLinkpathDest(linkPath, file.path);
          if (resolved && resolved.path === targetFile.path) {
            changed = true;
            const finalPath = this.getRelativePathForNote(file, newPath, linkPath);
            const altStr = alt ? `|${alt}` : "";
            return `![[${finalPath}${altStr}]]`;
          }
          return match;
        });
        const htmlRegex = /<img([^>]+)src=["']([^"']+)["']([^>]*)>/gi;
        newContent = newContent.replace(htmlRegex, (match, before, src, after) => {
          const resolved = this.app.metadataCache.getFirstLinkpathDest(src, file.path);
          if (resolved && resolved.path === targetFile.path) {
            changed = true;
            const finalPath = this.getRelativePathForNote(file, newPath, src);
            return `<img${before}src="${finalPath}"${after}>`;
          }
          return match;
        });
        return newContent;
      });
      if (changed)
        updatedCount++;
    }
    if (updatedCount > 0) {
      await this.appendDebugLog("VAULT_REFERENCES_UPDATED", { target: targetFile.path, updatedFiles: updatedCount });
    }
  }
  /**
   * Watch Mode handler for newly created files
   */
  async handleFileCreated(file) {
    if (!SUPPORTED_EXTENSIONS.includes(file.extension.toLowerCase()))
      return;
    if (file.name.includes("-rounded-"))
      return;
    const now = Date.now();
    const lastProcessed = this.recentlyProcessed.get(file.path) || 0;
    if (now - lastProcessed < 5e3) {
      return;
    }
    this.recentlyProcessed.set(file.path, now);
    if (this.settings.watchFolders.trim().length > 0) {
      const folders = this.settings.watchFolders.split(",").map((f) => f.trim().toLowerCase());
      const filePath = file.path.toLowerCase();
      const isInWatchedFolder = folders.some((folder) => filePath.includes(folder + "/"));
      if (!isInWatchedFolder)
        return;
    }
    await this.appendDebugLog("WATCH_MODE_TRIGGERED", { path: file.path });
    let targetViews = [];
    let attempts = 0;
    const filename = file.name;
    while (attempts < 10 && targetViews.length === 0) {
      const openMarkdownViews = this.app.workspace.getLeavesOfType("markdown").map((leaf) => leaf.view);
      for (const view of openMarkdownViews) {
        const content = view.editor.getValue();
        if (content.includes(filename)) {
          targetViews.push(view);
        }
      }
      if (targetViews.length === 0) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        attempts++;
      }
    }
    if (targetViews.length === 0) {
      await this.appendDebugLog("WATCH_MODE_SKIPPED", { path: file.path, reason: "Not found in any open note after 5s" });
      return;
    }
    const radius = this.settings.defaultUnit === "percent" ? this.settings.defaultPercent : this.settings.defaultPx;
    const unit = this.settings.defaultUnit;
    const shadow = {
      enabled: this.settings.enableShadow,
      color: this.settings.shadowColor,
      blur: this.settings.shadowBlur,
      offset: this.settings.shadowOffset
    };
    const border = {
      enabled: this.settings.enableBorder,
      color: this.settings.borderColor,
      width: this.settings.borderWidth,
      style: this.settings.borderStyle
    };
    try {
      let attemptsReady = 0;
      let ready = false;
      while (attemptsReady < 10) {
        const freshFile2 = this.app.vault.getAbstractFileByPath(file.path);
        if (freshFile2 && freshFile2 instanceof import_obsidian3.TFile && freshFile2.stat.size > 0) {
          ready = true;
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
        attemptsReady++;
      }
      if (!ready) {
        await this.appendDebugLog("WATCH_MODE_FILE_NOT_READY", { path: file.path });
        return;
      }
      const freshFile = this.app.vault.getAbstractFileByPath(file.path);
      const result = await this.processSingleImage(freshFile, radius, unit, shadow, border);
      if (result.success && result.newPath) {
        if (this.settings.dualImageSystem) {
          for (const view of targetViews) {
            const lineCount = view.editor.lineCount();
            for (let i = 0; i < lineCount; i++) {
              const line = view.editor.getLine(i);
              if (line.includes(filename)) {
                const match = this.findMatchInLine(line, i, { targetSrc: filename });
                if (match) {
                  const finalPath = this.getRelativePathForNote(view, result.newPath, match.path);
                  const processedPath = match.path.includes("%20") || match.path.includes(" ") ? finalPath.replace(/ /g, "%20") : finalPath;
                  const replacement = this.buildReference(match, processedPath);
                  view.editor.replaceRange(replacement, { line: i, ch: match.start }, { line: i, ch: match.end });
                }
              }
            }
          }
          await this.updateAllVaultReferences(freshFile, result.newPath);
          new import_obsidian3.Notice(`Watch Mode: Created rounded version of ${file.name}`, 3e3);
        } else {
          for (const view of targetViews) {
            this.refreshOpenNotes(freshFile.path);
          }
          new import_obsidian3.Notice(`Watch Mode: Rounded original ${file.name}`, 3e3);
        }
      }
    } catch (error) {
      console.error("Watch Mode processing failed:", error);
      await this.appendDebugLog("WATCH_MODE_FAILED", { path: file.path, error: String(error) });
    }
  }
  /**
   * Forces Obsidian to refresh its view of an image across all open notes.
   */
  refreshOpenNotes(filePath) {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      const content = view.editor.getValue();
      if (content.includes(filePath) || content.includes(path.basename(filePath))) {
        const editor = view.editor;
        const cursor = editor.getCursor();
        const lineCount = editor.lineCount();
        const lastLine = editor.getLine(lineCount - 1);
        editor.replaceRange(" ", { line: lineCount - 1, ch: lastLine.length });
        editor.replaceRange("", { line: lineCount - 1, ch: lastLine.length }, { line: lineCount - 1, ch: lastLine.length + 1 });
        editor.setCursor(cursor);
        if (view.previewMode && view.previewMode.rerender) {
          view.previewMode.rerender(true);
        }
      }
    }
  }
};
